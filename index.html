<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>What's My Workout?</title>

  <!-- PWA -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#0d0d14">
  <!-- iOS standalone mode -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="My Workout">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <!-- Supabase JS client — defer so it doesn't block page render; crossorigin for SW caching -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2" defer crossorigin="anonymous"></script>
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg: #0d0d14;
      --surface: #13131e;
      --surface2: #1a1a28;
      --border: #222235;
      --border-active: #4040a0;
      --accent: #6c63ff;
      --accent-dark: #4a42cc;
      --text-primary: #e4e4f4;
      --text-secondary: #6a6a90;
      --text-dim: #3a3a58;
      --red: #ff5555;
      --orange: #ff9944;
      --green: #3ecf8e;
      --red-bg: #2a0f0f;
      --orange-bg: #2a1a0a;
      --green-bg: #0a2018;
    }

    html {
      background: var(--bg);
    }

    body {
      background: var(--bg);
      color: var(--text-primary);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      min-height: 100vh;
      min-height: 100dvh;
      padding: env(safe-area-inset-top, 0) 0 env(safe-area-inset-bottom, 0);
      -webkit-font-smoothing: antialiased;
    }

    .container {
      max-width: 500px;
      margin: 0 auto;
      padding: 24px 16px 48px;
    }

    /* Header */
    header {
      text-align: center;
      margin-bottom: 28px;
    }

    header h1 {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-secondary);
      letter-spacing: 0.04em;
    }

    /* Today's date */
    .date-label {
      font-size: 0.72rem;
      color: var(--text-dim);
      margin-top: 4px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    /* Suggestion card */
    .suggestion-card {
      background: var(--surface2);
      border: 1px solid var(--border-active);
      border-radius: 22px;
      padding: 32px 24px 28px;
      margin-bottom: 28px;
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    .suggestion-card::before {
      content: '';
      position: absolute;
      top: -40px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 200px;
      background: radial-gradient(circle, rgba(108, 99, 255, 0.12) 0%, transparent 70%);
      pointer-events: none;
    }

    .suggestion-eyebrow {
      font-size: 0.68rem;
      font-weight: 700;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--accent);
      margin-bottom: 12px;
    }

    .suggestion-name {
      font-size: 2.2rem;
      font-weight: 800;
      color: var(--text-primary);
      line-height: 1.15;
      margin-bottom: 8px;
      letter-spacing: -0.02em;
    }

    .suggestion-subtitle {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 28px;
    }

    .done-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 16px;
      padding: 18px 48px;
      font-size: 1.05rem;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s, opacity 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      min-width: 180px;
    }

    .done-btn:active {
      background: var(--accent-dark);
      transform: scale(0.96);
    }

    .done-btn:disabled {
      background: var(--surface);
      color: var(--text-secondary);
      cursor: default;
      border: 1px solid var(--border);
    }

    .done-btn:disabled:active {
      transform: none;
    }

    .card-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .skip-btn {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 11px 28px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      min-width: 180px;
    }

    .skip-btn:active {
      background: var(--surface);
    }

    .skip-btn:disabled {
      opacity: 0.35;
      cursor: default;
    }

    .skip-btn:disabled:active {
      background: transparent;
    }

    /* Undo button */
    .undo-btn {
      background: transparent;
      border: none;
      color: var(--text-dim);
      font-size: 0.78rem;
      font-weight: 600;
      cursor: pointer;
      padding: 8px 16px;
      border-radius: 8px;
      transition: color 0.15s, background 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .undo-btn:active {
      color: var(--text-secondary);
      background: var(--surface);
    }

    /* Log for yesterday link inside each workout row */
    .log-yesterday-link {
      display: inline-block;
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 0.72rem;
      font-weight: 500;
      cursor: pointer;
      padding: 3px 0 0;
      margin-top: 1px;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      text-align: left;
    }

    .log-yesterday-link:active {
      color: var(--text-secondary);
    }

    /* Workout list */
    .list-header {
      font-size: 0.68rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-dim);
      margin-bottom: 10px;
      padding: 0 4px;
    }

    .workout-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .workout-row {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px 16px 16px 18px;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: border-color 0.2s, opacity 0.2s;
    }

    .workout-row.is-suggested {
      border-color: rgba(108, 99, 255, 0.4);
    }

    .workout-row.done-today {
      opacity: 0.45;
    }

    .workout-info {
      flex: 1;
      min-width: 0;
    }

    .workout-name {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 3px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .workout-last {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    /* Days pill */
    .days-pill {
      font-size: 0.78rem;
      font-weight: 700;
      padding: 5px 11px;
      border-radius: 20px;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .days-pill.urgent   { background: var(--red-bg);    color: var(--red);    }
    .days-pill.warning  { background: var(--orange-bg); color: var(--orange); }
    .days-pill.ok       { background: var(--green-bg);  color: var(--green);  }
    .days-pill.today    { background: var(--green-bg);  color: var(--green);  }

    /* Row done button */
    .row-done-btn {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 9px 14px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      flex-shrink: 0;
      transition: background 0.15s, border-color 0.15s, color 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      min-width: 56px;
    }

    .row-done-btn:active {
      background: var(--surface2);
    }

    .row-done-btn:disabled {
      opacity: 0.4;
      cursor: default;
    }

    /* Tomorrow row */
    .tomorrow-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 4px;
      margin-bottom: 20px;
    }

    .tomorrow-label {
      font-size: 0.68rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-dim);
    }

    .tomorrow-name {
      font-size: 0.82rem;
      font-weight: 600;
      color: var(--text-secondary);
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: calc(28px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: var(--surface2);
      border: 1px solid var(--border-active);
      color: var(--text-primary);
      padding: 13px 26px;
      border-radius: 14px;
      font-size: 0.9rem;
      font-weight: 600;
      pointer-events: none;
      opacity: 0;
      transition: transform 0.28s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
      white-space: nowrap;
      z-index: 100;
    }

    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>What's My Workout?</h1>
      <div class="date-label" id="date-label"></div>
    </header>

    <div class="suggestion-card" id="suggestion-card">
      <div class="suggestion-eyebrow">Next Up</div>
      <div class="suggestion-name" id="suggestion-name"></div>
      <div class="suggestion-subtitle" id="suggestion-subtitle"></div>
      <div class="card-actions">
        <button class="done-btn" id="main-done-btn">Done!</button>
        <button class="skip-btn" id="skip-btn">Skip Today</button>
        <button class="undo-btn" id="undo-btn" hidden></button>
      </div>
    </div>

    <div class="tomorrow-row">
      <span class="tomorrow-label">Tomorrow</span>
      <span class="tomorrow-name" id="tomorrow-name"></span>
    </div>

    <div class="list-header">All Workouts</div>
    <div class="workout-list" id="workout-list"></div>
  </div>

  <div class="toast" id="toast"></div>


  <script>
  // DOMContentLoaded ensures the deferred Supabase CDN script has executed before
  // app initialisation runs. Without this wrapper, the inline script would run
  // during HTML parsing — before the deferred script — and window.supabase
  // would be undefined.
  document.addEventListener('DOMContentLoaded', function () {

    // ── Supabase config ──────────────────────────────────────────────────────
    const SUPABASE_URL = '%%SUPABASE_URL%%';
    const SUPABASE_KEY = '%%SUPABASE_KEY%%';
    let sb = null;
    try {
      sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    } catch (e) {
      console.warn('Supabase unavailable; running in localStorage-only mode.', e);
    }
    // ────────────────────────────────────────────────────────────────────────

    const WORKOUTS = [
      { id: 'peloton',    name: 'Peloton Ride' },
      { id: 'upper_push', name: 'Upper Push'   },
      { id: 'upper_pull', name: 'Upper Pull'   },
      { id: 'lower',      name: 'Lower Body'   },
      { id: 'yoga',       name: 'Yoga'         },
    ];

    // Fixed rotation: Peloton every other slot, Yoga every 4th workout overall
    const ROTATION = [
      'peloton', 'upper_push',
      'peloton', 'yoga',
      'peloton', 'upper_pull',
      'peloton', 'yoga',
      'peloton', 'lower',
      'peloton', 'yoga',
    ];

    const STORAGE_KEY = 'wmw_v1';

    async function loadData() {
      if (!sb) {
        try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; }
        catch { return {}; }
      }
      try {
        const [stateRes, historyRes] = await Promise.all([
          sb.from('state').select('*').eq('id', 1).maybeSingle(),
          // Order by sequence (explicit insert order) rather than created_at so that
          // batch re-inserts — which share the same timestamp — come back in the
          // correct order.
          sb.from('history').select('*').order('sequence', { ascending: true, nullsFirst: true }),
        ]);
        if (stateRes.error) throw stateRes.error;
        if (historyRes.error) throw historyRes.error;

        const state = stateRes.data || {};
        const historyRows = historyRes.data || [];

        const data = {
          rotationIndex: state.rotation_index ?? 0,
          actionDate:    state.action_date   ?? null,
          history: historyRows.map(r => ({ type: r.type, date: r.date, advanced: r.advanced, _sid: r.id })),
        };

        // Derive each workout's last-done date from history
        for (const { type, date } of historyRows) {
          if (type !== 'off' && (!data[type] || date > data[type])) {
            data[type] = date;
          }
        }

        localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); // keep local cache fresh
        return data;
      } catch (err) {
        console.warn('Supabase read failed, falling back to localStorage:', err);
        try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; }
        catch { return {}; }
      }
    }

    async function saveData(data, deletedSid = null) {
      // Always write localStorage immediately so the fallback is always fresh
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      if (!sb) return; // localStorage-only mode (Supabase client unavailable)
      try {
        // Upsert the single state row (rotation position + today's lock)
        const { error: stateErr } = await sb.from('state').upsert({
          id: 1,
          rotation_index: data.rotationIndex ?? 0,
          action_date:    data.actionDate    ?? null,
        });
        if (stateErr) throw stateErr;

        // If this save was triggered by an undo, delete only that one row
        if (deletedSid) {
          const { error: delErr } = await sb.from('history').delete().eq('id', deletedSid);
          if (delErr) throw delErr;
        }

        // Insert only new entries — those not yet synced (no _sid means never written to Supabase)
        const newEntries = (data.history || []).filter(e => !e._sid);
        if (newEntries.length) {
          // sequence = the entry's position in the full history array, so ordering
          // by sequence always reproduces insertion order even across batch inserts
          // that share the same created_at timestamp.
          const rows = newEntries.map(e => ({
            type: e.type,
            date: e.date,
            advanced: e.advanced ?? true,
            sequence: data.history.indexOf(e),
          }));
          const { data: inserted, error: insErr } = await sb.from('history').insert(rows).select('id');
          if (insErr) throw insErr;
          // Store the Supabase-assigned IDs back so future saves know these rows exist
          inserted.forEach((row, i) => { newEntries[i]._sid = row.id; });
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }
      } catch (err) {
        console.warn('Supabase write failed (data saved locally):', err);
      }
    }

    function todayStr() {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    function getYesterdayStr() {
      const d = new Date();
      d.setDate(d.getDate() - 1);
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    function daysSince(dateStr) {
      if (!dateStr) return null;
      const [y, m, d] = dateStr.split('-').map(Number);
      const then = new Date(y, m - 1, d);
      const now = new Date();
      now.setHours(0, 0, 0, 0);
      return Math.round((now - then) / 86_400_000);
    }

    // Next workout is always the current rotation position
    function getSuggested(data) {
      const idx = (data.rotationIndex || 0) % ROTATION.length;
      return WORKOUTS.find(w => w.id === ROTATION[idx]);
    }

    function pillClass(days, doneToday) {
      if (doneToday)                  return 'today';
      if (days === null || days >= 6) return 'urgent';
      if (days >= 3)                  return 'warning';
      return 'ok';
    }

    function pillText(days, doneToday) {
      if (doneToday)     return 'Today';
      if (days === null) return 'Never';
      if (days === 1)    return '1 day';
      return `${days}d`;
    }

    function lastDoneText(days, doneToday) {
      if (doneToday)     return 'Completed today';
      if (days === null) return 'Never done';
      if (days === 1)    return 'Last done 1 day ago';
      return `Last done ${days} days ago`;
    }

    let toastTimer;
    function showToast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => el.classList.remove('show'), 1800);
    }

    // ── Double-tap guard ─────────────────────────────────────────────────────
    // Each action function sets this true at the start and false when complete
    // (via try/finally). Any tap that arrives during a network round-trip hits
    // the guard and returns immediately — no duplicate mutations.
    let isProcessing = false;

    function setButtonsDisabled(disabled) {
      ['main-done-btn', 'skip-btn', 'undo-btn'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = disabled;
      });
      document.querySelectorAll('.row-done-btn, .log-yesterday-link').forEach(el => {
        el.disabled = disabled;
      });
    }
    // ────────────────────────────────────────────────────────────────────────

    // Main "Done!" — logs the workout and advances the rotation
    async function markDone() {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const today = todayStr();
        const idx = (data.rotationIndex || 0) % ROTATION.length;
        const workoutId = ROTATION[idx];

        data[workoutId] = today;                              // keep last-done date for the UI
        data.rotationIndex = (idx + 1) % ROTATION.length;    // advance rotation
        data.actionDate = today;                              // lock today's card
        data.history = data.history || [];
        data.history.push({ type: workoutId, date: today, advanced: true });

        await saveData(data);
        render(data);
        showToast('Logged \u2713');
      } finally {
        isProcessing = false;
      }
    }

    // "Skip Today" — logs an off day, rotation stays put
    async function skipToday() {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const today = todayStr();

        data.actionDate = today;
        data.history = data.history || [];
        data.history.push({ type: 'off', date: today, advanced: false });

        await saveData(data);
        render(data);
        showToast('Day off logged');
      } finally {
        isProcessing = false;
      }
    }

    // Undo — removes the most recent history entry if it's from today or yesterday
    async function undoLastEntry() {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const today = todayStr();
        const yesterday = getYesterdayStr();
        const history = data.history || [];
        if (!history.length) { render(data); return; }

        const last = history[history.length - 1];
        if (last.date !== today && last.date !== yesterday) { render(data); return; }

        const deletedSid = last._sid ?? null; // capture before removing so saveData can delete the right row

        // Remove the entry
        data.history = history.slice(0, -1);

        // Restore the previous last-done date for this workout type
        if (last.type !== 'off') {
          const prev = [...data.history].reverse().find(e => e.type === last.type);
          if (prev) {
            data[last.type] = prev.date;
          } else {
            delete data[last.type];
          }
        }

        // Roll back rotation if this entry advanced it.
        // New entries use advanced:true/false explicitly.
        // Old entries (no 'advanced' key) are assumed rotation-advancing if they're a workout,
        // since only markDone logged workouts before the advanced flag was introduced.
        const wasRotationAdvancing =
          last.advanced === true ||
          (!('advanced' in last) && last.type !== 'off');
        if (wasRotationAdvancing) {
          data.rotationIndex = ((data.rotationIndex || 0) - 1 + ROTATION.length) % ROTATION.length;
        }

        // Recalculate actionDate from what remains in history rather than guessing.
        // The card is locked today only if a rotation-advancing done or a skip still exists for today.
        const stillLockedToday = (data.history || []).some(e =>
          e.date === today && (
            e.advanced === true ||                          // new markDone entry
            e.type === 'off' ||                            // skip entry
            (!('advanced' in e) && e.type !== 'off')       // old entry without flag (backward compat)
          )
        );
        if (stillLockedToday) {
          data.actionDate = today;
        } else {
          delete data.actionDate;
        }

        await saveData(data, deletedSid);
        render(data);
        const name = last.type === 'off'
          ? 'day off'
          : (WORKOUTS.find(w => w.id === last.type)?.name ?? last.type);
        showToast(`Undone \u2014 ${name}`);
      } finally {
        isProcessing = false;
      }
    }

    // Log for yesterday — adds a history entry for yesterday without touching the rotation
    async function logYesterday(type) {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const yesterday = getYesterdayStr();

        if (type !== 'off') {
          // Only update the last-done date if yesterday is more recent than what's stored
          const current = data[type];
          if (!current || yesterday > current) {
            data[type] = yesterday;
          }
        }

        data.history = data.history || [];
        data.history.push({ type, date: yesterday, advanced: false });

        await saveData(data);
        render(data);
        const name = type === 'off'
          ? 'Day off'
          : (WORKOUTS.find(w => w.id === type)?.name ?? type);
        showToast(`${name} \u2014 logged for yesterday`);
      } finally {
        isProcessing = false;
      }
    }

    // Row-level done — marks a specific workout without affecting the rotation
    async function markRowDone(id) {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const today = todayStr();

        data[id] = today;
        data.history = data.history || [];
        data.history.push({ type: id, date: today, advanced: false });

        await saveData(data);
        render(data);
        showToast('Logged \u2713');
      } finally {
        isProcessing = false;
      }
    }

    async function render(preloadedData = null) {
      const data = preloadedData || await loadData();
      const today = todayStr();
      const yesterday = getYesterdayStr();
      const nextInRotation = getSuggested(data);
      const actionTakenToday = data.actionDate === today;

      // What specifically happened today (if anything)
      const todayEntry = [...(data.history || [])].reverse().find(e => e.date === today);
      const skippedToday = todayEntry?.type === 'off';

      // Hero card stays on the completed workout for the rest of the day.
      // Only flip to the next rotation item when a new day begins.
      const heroWorkout = (actionTakenToday && !skippedToday && todayEntry)
        ? (WORKOUTS.find(w => w.id === todayEntry.type) || nextInRotation)
        : nextInRotation;

      // Date label
      document.getElementById('date-label').textContent = new Date().toLocaleDateString(
        undefined, { weekday: 'long', month: 'long', day: 'numeric' }
      );

      // Suggestion card
      const sugDays = data[heroWorkout.id] ? daysSince(data[heroWorkout.id]) : null;
      document.getElementById('suggestion-name').textContent = heroWorkout.name;

      let subtitleText;
      if (skippedToday)        subtitleText = 'Day off \u2014 same workout tomorrow';
      else if (actionTakenToday) subtitleText = 'Completed today';
      else                       subtitleText = lastDoneText(sugDays, false);
      document.getElementById('suggestion-subtitle').textContent = subtitleText;

      const mainBtn = document.getElementById('main-done-btn');
      mainBtn.disabled = actionTakenToday;
      mainBtn.textContent = (actionTakenToday && !skippedToday) ? 'Done Today \u2713' : 'Done!';
      mainBtn.onclick = actionTakenToday ? null : markDone;

      const skipBtn = document.getElementById('skip-btn');
      skipBtn.disabled = actionTakenToday;
      skipBtn.textContent = skippedToday ? 'Skipped Today' : 'Skip Today';
      skipBtn.onclick = actionTakenToday ? null : skipToday;

      // Undo button — visible when the most recent history entry is from today or yesterday
      const history = data.history || [];
      const undoCandidate = history.length ? history[history.length - 1] : null;
      const undoBtn = document.getElementById('undo-btn');
      if (undoCandidate && (undoCandidate.date === today || undoCandidate.date === yesterday)) {
        const undoName = undoCandidate.type === 'off'
          ? 'day off'
          : (WORKOUTS.find(w => w.id === undoCandidate.type)?.name ?? undoCandidate.type);
        const undoWhen = undoCandidate.date === today ? 'today' : 'yesterday';
        undoBtn.textContent = `\u21a9 Undo ${undoName} (${undoWhen})`;
        undoBtn.onclick = undoLastEntry;
        undoBtn.hidden = false;
      } else {
        undoBtn.hidden = true;
      }

      // Tomorrow row — one step ahead of whatever is currently next
      // If action was taken today, rotation already advanced so nextInRotation IS tomorrow.
      // If today hasn't been actioned yet, rotation still points to today, so add 1.
      const tomorrowWorkout = actionTakenToday
        ? nextInRotation
        : WORKOUTS.find(w => w.id === ROTATION[((data.rotationIndex || 0) + 1) % ROTATION.length]);
      document.getElementById('tomorrow-name').textContent = tomorrowWorkout.name;

      // Workout list — suggested first, then by most recently done
      const sorted = [...WORKOUTS].sort((a, b) => {
        if (a.id === nextInRotation.id) return -1;
        if (b.id === nextInRotation.id) return 1;
        const doneA = data[a.id] === today;
        const doneB = data[b.id] === today;
        const daysA = data[a.id] ? daysSince(data[a.id]) : null;
        const daysB = data[b.id] ? daysSince(data[b.id]) : null;
        const scoreA = doneA ? -1 : (daysA === null ? Infinity : daysA);
        const scoreB = doneB ? -1 : (daysB === null ? Infinity : daysB);
        return scoreB - scoreA;
      });

      const list = document.getElementById('workout-list');
      list.innerHTML = '';

      for (const w of sorted) {
        const last = data[w.id];
        const days = last ? daysSince(last) : null;
        const doneToday = last === today;
        const isSuggested = w.id === nextInRotation.id;

        const row = document.createElement('div');
        row.className = [
          'workout-row',
          isSuggested ? 'is-suggested' : '',
          doneToday   ? 'done-today'   : '',
        ].filter(Boolean).join(' ');

        const info = document.createElement('div');
        info.className = 'workout-info';

        const nameEl = document.createElement('div');
        nameEl.className = 'workout-name';
        nameEl.textContent = w.name;

        const lastEl = document.createElement('div');
        lastEl.className = 'workout-last';
        lastEl.textContent = lastDoneText(days, doneToday);

        info.appendChild(nameEl);
        info.appendChild(lastEl);

        // "Log for yesterday" link — hidden if this workout was already logged for yesterday
        const alreadyLoggedYesterday = history.some(e => e.date === yesterday && e.type === w.id);
        if (!alreadyLoggedYesterday) {
          const yLink = document.createElement('button');
          yLink.className = 'log-yesterday-link';
          yLink.textContent = '\u21a9 Log for yesterday';
          yLink.onclick = () => logYesterday(w.id);
          info.appendChild(yLink);
        }

        const pill = document.createElement('span');
        pill.className = 'days-pill ' + pillClass(days, doneToday);
        pill.textContent = pillText(days, doneToday);

        const btn = document.createElement('button');
        btn.className = 'row-done-btn';
        btn.textContent = doneToday ? '\u2713' : 'Done';
        btn.disabled = doneToday;
        if (!doneToday) btn.onclick = () => markRowDone(w.id);

        row.appendChild(info);
        row.appendChild(pill);
        row.appendChild(btn);
        list.appendChild(row);
      }

    }

    render();

  }); // end DOMContentLoaded

  // Register service worker outside DOMContentLoaded so it starts as early as
  // possible — it does not depend on the Supabase client.
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js').catch(() => {});
    });
  }
  </script>
</body>
</html>
