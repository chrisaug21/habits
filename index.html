<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>What's My Workout?</title>

  <!-- PWA -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#0d0d14">
  <!-- iOS standalone mode -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="My Workout">
  <link rel="icon" href="/favicon.ico" sizes="48x48">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <!-- Supabase JS client — defer so it doesn't block page render; crossorigin for SW caching -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2" defer crossorigin="anonymous"></script>
  <!-- Lucide Icons — defer matches Supabase script; crossorigin for SW caching -->
  <script src="https://cdn.jsdelivr.net/npm/lucide@0.563.0/dist/umd/lucide.min.js" defer crossorigin="anonymous"></script>
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* Ensure the HTML `hidden` attribute always wins over any display: rule */
    [hidden] { display: none !important; }

    :root {
      --bg: #0d0d14;
      --surface: #13131e;
      --surface2: #1a1a28;
      --border: #222235;
      --border-active: #4040a0;
      --accent: #6c63ff;
      --accent-dark: #4a42cc;
      --text-primary: #e4e4f4;
      --text-secondary: #6a6a90;
      --text-dim: #3a3a58;
      --red: #ff5555;
      --orange: #ff9944;
      --green: #3ecf8e;
      --amber: #f59e0b;
      --teal: #2dd4bf;
      --red-bg: #2a0f0f;
      --orange-bg: #2a1a0a;
      --green-bg: #0a2018;
    }

    html {
      background: var(--bg);
    }

    body {
      background: var(--bg);
      color: var(--text-primary);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      min-height: 100vh;
      min-height: 100dvh;
      padding: env(safe-area-inset-top, 0) 0 0;
      -webkit-font-smoothing: antialiased;
    }

    .container {
      max-width: 500px;
      margin: 0 auto;
      /* Extra bottom padding so content scrolls above the fixed bottom nav */
      padding: 24px 16px calc(80px + env(safe-area-inset-bottom, 0px));
    }

    /* Header */
    header {
      text-align: center;
      margin-bottom: 28px;
    }

    header h1 {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-secondary);
      letter-spacing: 0.04em;
    }

    /* Today's date */
    .date-label {
      font-size: 0.72rem;
      color: var(--text-dim);
      margin-top: 4px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    /* Suggestion card */
    .suggestion-card {
      background: var(--surface2);
      border: 1px solid var(--border-active);
      border-radius: 22px;
      padding: 32px 24px 28px;
      margin-bottom: 28px;
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    .suggestion-card::before {
      content: '';
      position: absolute;
      top: -40px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 200px;
      background: radial-gradient(circle, rgba(108, 99, 255, 0.12) 0%, transparent 70%);
      pointer-events: none;
    }

    .suggestion-eyebrow {
      font-size: 0.68rem;
      font-weight: 700;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--accent);
      margin-bottom: 12px;
    }

    /* Hero icon — on its own line, centered, above the workout name */
    .hero-icon-wrap {
      display: flex;
      justify-content: center;
      margin-bottom: 14px;
    }

    .hero-icon-wrap i,
    .hero-icon-wrap svg {
      width: 48px;
      height: 48px;
      color: var(--accent);
    }

    /* Rest-day moon shown in amber */
    .hero-icon-wrap.is-rest i,
    .hero-icon-wrap.is-rest svg {
      color: var(--amber);
    }

    /* Other-activity zap shown in teal */
    .hero-icon-wrap.is-other i,
    .hero-icon-wrap.is-other svg {
      color: var(--teal);
    }

    .suggestion-name {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--text-primary);
      line-height: 1.2;
      margin-bottom: 8px;
      letter-spacing: -0.02em;
    }

    .suggestion-subtitle {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 28px;
    }

    .done-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 16px;
      padding: 18px 48px;
      font-size: 1.05rem;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s, opacity 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      min-width: 180px;
    }

    .done-btn:active {
      background: var(--accent-dark);
      transform: scale(0.96);
    }

    .done-btn:disabled {
      background: var(--surface);
      color: var(--text-secondary);
      cursor: default;
      border: 1px solid var(--border);
    }

    .done-btn:disabled:active {
      transform: none;
    }

    .card-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .skip-btn {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 11px 28px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      min-width: 180px;
    }

    .skip-btn:active {
      background: var(--surface);
    }

    .skip-btn:disabled {
      opacity: 0.35;
      cursor: default;
    }

    .skip-btn:disabled:active {
      background: transparent;
    }

    /* Undo button — ghost style, comfortable tap target */
    .undo-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 7px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      padding: 12px 24px;
      min-height: 44px;
      min-width: 180px;
      border-radius: 12px;
      transition: color 0.15s, background 0.15s, border-color 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .undo-btn i,
    .undo-btn svg {
      width: 15px;
      height: 15px;
    }

    .undo-btn:active {
      background: var(--surface);
      color: var(--text-primary);
      border-color: var(--text-dim);
    }

    /* Workout list */
    .list-header {
      font-size: 0.68rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-dim);
      margin-bottom: 10px;
      padding: 0 4px;
    }

    .workout-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .workout-row {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px 16px 16px 18px;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: border-color 0.2s, opacity 0.2s;
    }

    .workout-row.is-suggested {
      border-color: rgba(108, 99, 255, 0.4);
    }

    .workout-row.done-today {
      opacity: 0.45;
    }

    .workout-info {
      flex: 1;
      min-width: 0;
    }

    .workout-name {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 3px;
      display: flex;
      align-items: center;
      gap: 7px;
    }

    .workout-name span {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Workout type icons */
    .row-icon {
      flex-shrink: 0;
      width: 15px;
      height: 15px;
      color: var(--text-secondary);
    }

    .workout-last {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    /* Days pill */
    .days-pill {
      font-size: 0.78rem;
      font-weight: 700;
      padding: 5px 11px;
      border-radius: 20px;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .days-pill.urgent   { background: var(--red-bg);    color: var(--red);    }
    .days-pill.warning  { background: var(--orange-bg); color: var(--orange); }
    .days-pill.ok       { background: var(--green-bg);  color: var(--green);  }
    .days-pill.today    { background: var(--green-bg);  color: var(--green);  }

    /* Row done button */
    .row-done-btn {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 9px 14px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      flex-shrink: 0;
      transition: background 0.15s, border-color 0.15s, color 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      min-width: 56px;
    }

    .row-done-btn:active {
      background: var(--surface2);
    }

    .row-done-btn:disabled {
      opacity: 0.4;
      cursor: default;
    }

    /* Tomorrow preview */
    .tomorrow-preview {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px 20px 18px;
      margin-bottom: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      text-align: center;
    }

    .tomorrow-label {
      font-size: 0.68rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-dim);
    }

    .tomorrow-name {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 7px;
    }

    .tomorrow-name .tomorrow-icon {
      width: 16px;
      height: 16px;
      color: var(--text-secondary);
      flex-shrink: 0;
    }

    /* Toast — raised above the bottom nav bar */
    .toast {
      position: fixed;
      bottom: calc(72px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: var(--surface2);
      border: 1px solid var(--border-active);
      color: var(--text-primary);
      padding: 13px 26px;
      border-radius: 14px;
      font-size: 0.9rem;
      font-weight: 600;
      pointer-events: none;
      opacity: 0;
      transition: transform 0.28s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
      white-space: nowrap;
      z-index: 100;
    }

    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* ── Bottom Navigation ─────────────────────────────────────────────────── */
    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--surface);
      border-top: 1px solid var(--border);
      display: flex;
      z-index: 50;
      /* Push visible content above the iPhone home bar */
      padding-bottom: env(safe-area-inset-bottom, 0px);
    }

    .nav-btn {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 10px 0;
      min-height: 56px;
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 0.62rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      transition: color 0.15s;
    }

    .nav-btn.active {
      color: var(--accent);
    }

    /* Target both the placeholder <i> and the SVG lucide generates */
    .nav-btn i,
    .nav-btn svg {
      width: 22px;
      height: 22px;
    }

    /* ── History view ──────────────────────────────────────────────────────── */

    /* Sub-tab row: Calendar / List toggle */
    .history-tabs {
      display: flex;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 4px;
      margin-bottom: 20px;
    }

    .htab {
      flex: 1;
      padding: 10px;
      background: none;
      border: none;
      border-radius: 10px;
      color: var(--text-secondary);
      font-size: 0.88rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .htab.active {
      background: var(--surface2);
      color: var(--accent);
    }

    /* ── Calendar ──────────────────────────────────────────────────────────── */
    .cal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .cal-month-label {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-primary);
    }

    .cal-nav-btn {
      background: none;
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-secondary);
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      transition: background 0.15s, color 0.15s;
    }

    .cal-nav-btn:active {
      background: var(--surface2);
      color: var(--text-primary);
    }

    .cal-nav-btn i,
    .cal-nav-btn svg {
      width: 16px;
      height: 16px;
    }

    .cal-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 3px;
    }

    .cal-dow {
      text-align: center;
      font-size: 0.6rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-dim);
      padding: 2px 0 8px;
    }

    .cal-day {
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      border-radius: 8px;
    }

    .cal-day.is-today {
      background: rgba(108, 99, 255, 0.12);
      outline: 1px solid rgba(108, 99, 255, 0.35);
    }

    /* Day number inside each cell */
    .cal-day-num {
      font-size: 0.68rem;
      font-weight: 600;
      color: var(--text-dim);
      line-height: 1;
    }

    .cal-day.is-today .cal-day-num {
      color: var(--text-primary);
      font-weight: 700;
    }

    /* Cells with actual logged data get a slightly brighter number */
    .cal-day.has-workout .cal-day-num,
    .cal-day.has-rest .cal-day-num {
      color: var(--text-secondary);
    }

    /* Small icon inside calendar cells */
    .cal-icon,
    .cal-day svg {
      width: 13px;
      height: 13px;
    }

    .cal-day.has-workout .cal-icon,
    .cal-day.has-workout svg {
      color: var(--accent);
    }

    .cal-day.has-rest .cal-icon,
    .cal-day.has-rest svg {
      color: var(--amber);
    }

    .cal-day.has-other .cal-day-num {
      color: var(--text-secondary);
    }

    .cal-day.has-other .cal-icon,
    .cal-day.has-other svg {
      color: var(--teal);
    }

    /* Projected future days: dimmed icon */
    .cal-day.is-projected .cal-icon,
    .cal-day.is-projected svg {
      color: var(--text-dim);
      opacity: 0.7;
    }

    /* Today's un-logged workout: bright white, not dimmed */
    .cal-day.is-today.is-projected .cal-icon,
    .cal-day.is-today.is-projected svg {
      color: var(--text-primary);
      opacity: 1;
    }

    /* ── History List ──────────────────────────────────────────────────────── */
    .hlist {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .hlist-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
    }

    .hlist-row.is-today {
      border-color: rgba(108, 99, 255, 0.4);
      background: var(--surface2);
    }

    /* Projected rows are faded */
    .hlist-row.is-projected {
      opacity: 0.4;
    }

    .hlist-icon {
      flex-shrink: 0;
      width: 16px;
      height: 16px;
      color: var(--text-dim);
    }

    .hlist-icon.purple { color: var(--accent); }
    .hlist-icon.amber  { color: var(--amber); }
    .hlist-icon.teal   { color: var(--teal); }

    .hlist-date {
      flex: 1;
      min-width: 0;
    }

    .hlist-date-main {
      font-size: 0.82rem;
      font-weight: 700;
      color: var(--text-primary);
      line-height: 1.2;
    }

    .hlist-date-sub {
      font-size: 0.7rem;
      color: var(--text-secondary);
      margin-top: 1px;
    }

    .hlist-name {
      font-size: 0.78rem;
      font-weight: 600;
      color: var(--text-secondary);
      text-align: right;
      flex-shrink: 0;
      max-width: 52%;
    }

    .hlist-name.purple { color: var(--text-primary); }
    .hlist-name.amber  { color: var(--amber); }
    .hlist-name.teal   { color: var(--teal); }

    .hlist-section-label {
      font-size: 0.62rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-dim);
      padding: 20px 4px 8px;
    }

    .hlist-empty {
      text-align: center;
      color: var(--text-dim);
      font-size: 0.85rem;
      padding: 48px 0 24px;
    }

    /* ── Test Mode Banner ─────────────────────────────────────────────────── */
    .test-banner {
      background: rgba(245, 158, 11, 0.12);
      border-bottom: 2px solid var(--amber);
      color: var(--amber);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 14px;
      padding: 11px 16px;
      font-size: 0.72rem;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .test-reset-btn {
      background: var(--amber);
      color: #0d0d14;
      border: none;
      border-radius: 8px;
      padding: 6px 14px;
      font-size: 0.7rem;
      font-weight: 800;
      cursor: pointer;
      letter-spacing: 0.04em;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      transition: opacity 0.15s;
    }

    .test-reset-btn:active {
      opacity: 0.7;
    }

    /* ── Other Activity Modal ──────────────────────────────────────────────── */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      z-index: 200;
      display: flex;
      align-items: flex-end;
    }

    .modal-sheet {
      background: var(--surface);
      border: 1px solid var(--border);
      border-top: 1px solid var(--border-active);
      border-radius: 24px 24px 0 0;
      padding: 28px 20px calc(28px + env(safe-area-inset-bottom, 0px));
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .modal-title {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-primary);
      text-align: center;
    }

    .modal-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .activity-chip {
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 9px 16px;
      font-size: 0.82rem;
      font-weight: 600;
      color: var(--text-secondary);
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      transition: background 0.15s, color 0.15s, border-color 0.15s;
    }

    .activity-chip:active {
      background: rgba(108, 99, 255, 0.15);
      border-color: var(--accent);
      color: var(--accent);
    }

    .modal-input {
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 14px 16px;
      font-size: 0.95rem;
      color: var(--text-primary);
      width: 100%;
      outline: none;
      font-family: inherit;
      transition: border-color 0.15s;
      -webkit-appearance: none;
    }

    .modal-input:focus {
      border-color: var(--accent);
    }

    .modal-input::placeholder {
      color: var(--text-dim);
    }

    .modal-actions {
      display: flex;
      gap: 10px;
    }

    .modal-confirm-btn {
      flex: 1;
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 14px;
      padding: 16px;
      font-size: 0.95rem;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.15s, opacity 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .modal-confirm-btn:disabled {
      opacity: 0.35;
      cursor: default;
    }

    .modal-confirm-btn:active:not(:disabled) {
      background: var(--accent-dark);
    }

    .modal-cancel-btn {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px 20px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .modal-cancel-btn:active {
      background: var(--surface2);
    }

    /* ── Modal icon (moon in Skip Today sheet) ──────────────────────────────── */
    .modal-icon {
      display: flex;
      justify-content: center;
    }
    .modal-icon i,
    .modal-icon svg {
      width: 32px;
      height: 32px;
      color: var(--accent);
    }
    .modal-icon.is-rest i,
    .modal-icon.is-rest svg {
      color: var(--amber);
    }

    /* ── History list note (skip reason under Rest Day) ─────────────────────── */
    .hlist-name-wrap {
      flex-shrink: 0;
      max-width: 52%;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }
    .hlist-name-wrap .hlist-name {
      max-width: 100%;
    }
    .hlist-note {
      font-size: 0.7rem;
      color: var(--text-secondary);
      text-align: right;
      margin-top: 2px;
    }

    /* ── Version stamp ──────────────────────────────────────────────────────── */
    #version-stamp {
      text-align: center;
      font-size: 11px;
      color: var(--text-dim);
      margin-top: 24px;
      user-select: none;
      -webkit-user-select: none;
    }

    /* ── Past day tap affordance in calendar ────────────────────────────────── */
    .cal-day.is-past {
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .cal-day.is-past:active {
      background: rgba(108, 99, 255, 0.1);
    }

    /* ── Backfill Modal ──────────────────────────────────────────────────────── */
    #backfill-sheet {
      max-height: 90vh;
      overflow-y: auto;
    }

    .backfill-date-label {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-primary);
      text-align: center;
    }

    /* Scrollable list of 7 selectable options */
    .backfill-options {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .backfill-option {
      display: flex;
      align-items: center;
      gap: 12px;
      width: 100%;
      padding: 14px 16px;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 14px;
      color: var(--text-primary);
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      text-align: left;
      transition: border-color 0.15s, background 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .backfill-option i,
    .backfill-option svg {
      width: 18px;
      height: 18px;
      color: var(--text-secondary);
      flex-shrink: 0;
    }

    .backfill-option.selected {
      border-color: var(--accent);
      background: rgba(108, 99, 255, 0.1);
    }

    .backfill-option.selected i,
    .backfill-option.selected svg {
      color: var(--accent);
    }

    .backfill-option.is-rest.selected i,
    .backfill-option.is-rest.selected svg {
      color: var(--amber);
    }

    .backfill-option.is-rest.selected {
      border-color: var(--amber);
      background: rgba(245, 158, 11, 0.1);
    }

    .backfill-option.is-other.selected i,
    .backfill-option.is-other.selected svg {
      color: var(--teal);
    }

    .backfill-option.is-other.selected {
      border-color: var(--teal);
      background: rgba(45, 212, 191, 0.08);
    }

    /* Read-only entry display */
    .backfill-readonly-entry {
      display: flex;
      align-items: center;
      gap: 14px;
      padding: 20px 18px;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 16px;
    }

    .backfill-readonly-icon i,
    .backfill-readonly-icon svg {
      width: 24px;
      height: 24px;
      color: var(--accent);
    }

    .backfill-readonly-icon.is-rest i,
    .backfill-readonly-icon.is-rest svg {
      color: var(--amber);
    }

    .backfill-readonly-icon.is-other i,
    .backfill-readonly-icon.is-other svg {
      color: var(--teal);
    }

    .backfill-readonly-name {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-primary);
    }

    /* Other activity section inside backfill edit view */
    #backfill-other-section {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 2px;
    }
  </style>
</head>
<body>
  <!-- ── Test Mode Banner ────────────────────────────────────────────────── -->
  <div class="test-banner" id="test-banner" hidden>
    TEST MODE — no real data affected
    <button class="test-reset-btn" id="test-reset-btn">Reset</button>
    <button class="test-reset-btn" id="test-exit-btn">Exit</button>
  </div>

  <div class="container">
    <header>
      <h1>What's My Workout?</h1>
      <div class="date-label" id="date-label"></div>
    </header>

    <!-- ── Today view ─────────────────────────────────────────────────────── -->
    <div id="view-today">
      <div class="suggestion-card" id="suggestion-card">
        <div class="suggestion-eyebrow" id="suggestion-eyebrow">Next Up</div>
        <div class="hero-icon-wrap" id="hero-icon-wrap">
          <i data-lucide="dumbbell"></i>
        </div>
        <div class="suggestion-name" id="suggestion-name"></div>
        <div class="suggestion-subtitle" id="suggestion-subtitle"></div>
        <div class="card-actions">
          <button class="done-btn" id="main-done-btn">Done!</button>
          <button class="skip-btn" id="skip-btn">Skip Today</button>
          <button class="skip-btn" id="log-other-btn">Log Other Activity</button>
          <button class="undo-btn" id="undo-btn" hidden></button>
        </div>
      </div>

      <div class="tomorrow-preview">
        <span class="tomorrow-label">Tomorrow</span>
        <span class="tomorrow-name" id="tomorrow-name"></span>
      </div>

      <div class="list-header">All Workouts</div>
      <div class="workout-list" id="workout-list"></div>

      <div id="version-stamp"></div>
    </div>

    <!-- ── History view ───────────────────────────────────────────────────── -->
    <div id="view-history" hidden>
      <div class="history-tabs">
        <button class="htab active" id="htab-calendar">Calendar</button>
        <button class="htab" id="htab-list">List</button>
      </div>
      <div id="hview-calendar"></div>
      <div id="hview-list" hidden></div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- ── Other Activity Modal ────────────────────────────────────────────── -->
  <div class="modal-overlay" id="other-activity-modal" hidden>
    <div class="modal-sheet">
      <div class="modal-title">Log Other Activity</div>
      <div class="modal-chips" id="other-activity-chips"></div>
      <input class="modal-input" id="other-activity-input" type="text"
             placeholder="Activity name…" maxlength="100" autocomplete="off">
      <div class="modal-actions">
        <button class="modal-cancel-btn" id="modal-cancel-btn">Cancel</button>
        <button class="modal-confirm-btn" id="modal-confirm-btn" disabled>Log It</button>
      </div>
    </div>
  </div>

  <!-- ── Skip Today Modal ──────────────────────────────────────────────── -->
  <div class="modal-overlay" id="skip-modal" hidden>
    <div class="modal-sheet">
      <div class="modal-icon is-rest">
        <i data-lucide="moon"></i>
      </div>
      <div class="modal-title">Rest Day</div>
      <div class="modal-chips" id="skip-reason-chips"></div>
      <input class="modal-input" id="skip-reason-input" type="text"
             placeholder="Reason (optional)" maxlength="100" autocomplete="off">
      <div class="modal-actions">
        <button class="modal-cancel-btn" id="skip-cancel-btn">Cancel</button>
        <button class="modal-confirm-btn" id="skip-confirm-btn">Skip Today</button>
      </div>
    </div>
  </div>

  <!-- ── Backfill Modal ───────────────────────────────────────────────────── -->
  <div class="modal-overlay" id="backfill-modal" hidden>
    <div class="modal-sheet" id="backfill-sheet">
      <div class="backfill-date-label" id="backfill-date-label"></div>

      <!-- Read-only view (shown when entry already exists) -->
      <div id="backfill-readonly" hidden>
        <div class="backfill-readonly-entry">
          <div class="backfill-readonly-icon" id="backfill-readonly-icon">
            <i data-lucide="dumbbell"></i>
          </div>
          <div class="backfill-readonly-name" id="backfill-readonly-name"></div>
        </div>
        <div class="modal-actions" style="margin-top:4px">
          <button class="modal-cancel-btn" id="backfill-ro-close-btn">Close</button>
          <button class="modal-confirm-btn" id="backfill-edit-btn">Edit</button>
        </div>
      </div>

      <!-- Edit / new-entry view -->
      <div id="backfill-edit-view">
        <div class="backfill-options" id="backfill-options"></div>
        <div id="backfill-other-section" hidden>
          <div class="modal-chips" id="backfill-other-chips"></div>
          <input class="modal-input" id="backfill-other-input" type="text"
                 placeholder="Activity name…" maxlength="100" autocomplete="off">
        </div>
        <div class="modal-actions">
          <button class="modal-cancel-btn" id="backfill-cancel-btn">Cancel</button>
          <button class="modal-confirm-btn" id="backfill-confirm-btn" disabled>Confirm</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ── Bottom Navigation ──────────────────────────────────────────────── -->
  <nav class="bottom-nav">
    <button class="nav-btn active" id="nav-today-btn">
      <i data-lucide="dumbbell"></i>
      <span>Today</span>
    </button>
    <button class="nav-btn" id="nav-history-btn">
      <i data-lucide="calendar"></i>
      <span>History</span>
    </button>
  </nav>

  <script>
  // DOMContentLoaded ensures the deferred Supabase CDN script has executed before
  // app initialisation runs. Without this wrapper, the inline script would run
  // during HTML parsing — before the deferred script — and window.supabase
  // would be undefined.
  document.addEventListener('DOMContentLoaded', function () {

    // ── Supabase config ──────────────────────────────────────────────────────
    const SUPABASE_URL = '%%SUPABASE_URL%%';
    const SUPABASE_KEY = '%%SUPABASE_KEY%%';
    let sb = null;
    try {
      sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    } catch (e) {
      console.warn('Supabase unavailable; running in localStorage-only mode.', e);
    }
    // ────────────────────────────────────────────────────────────────────────

    const WORKOUTS = [
      { id: 'peloton',    name: 'Cardio \u2014 Peloton Ride',    icon: 'bike'            },
      { id: 'upper_push', name: 'Strength \u2014 Upper Push',    icon: 'dumbbell'        },
      { id: 'upper_pull', name: 'Strength \u2014 Upper Pull',    icon: 'dumbbell'        },
      { id: 'lower',      name: 'Strength \u2014 Lower Body',    icon: 'dumbbell'        },
      { id: 'yoga',       name: 'Flexibility \u2014 Yoga',       icon: 'flower-2'        },
    ];

    // Fixed rotation: Peloton every other slot, Yoga every 4th workout overall
    const ROTATION = [
      'peloton', 'upper_push',
      'peloton', 'yoga',
      'peloton', 'upper_pull',
      'peloton', 'yoga',
      'peloton', 'lower',
      'peloton', 'yoga',
    ];

    const VERSION = '1.0.31';

    // ── Test mode ────────────────────────────────────────────────────────────
    const TEST_MODE = new URLSearchParams(window.location.search).get('test') === 'true';
    const STORAGE_KEY = TEST_MODE ? 'wmw_test' : 'wmw_v1';
    // ────────────────────────────────────────────────────────────────────────

    async function loadData() {
      if (!sb || TEST_MODE) {
        try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; }
        catch { return {}; }
      }
      try {
        // ── Offline sync ────────────────────────────────────────────────────────
        // Entries written while offline have no _sid — they were saved to
        // localStorage only. Push them to Supabase before the normal read so
        // they are not silently overwritten by stale remote state.
        let local = {};
        try { local = JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; } catch {}
        const unsynced = (local.history || []).filter(e => !e._sid);
        if (unsynced.length) {
          // Check whether local state (rotation / actionDate) is ahead of Supabase
          const { data: remoteState, error: stateReadErr } = await sb.from('state')
            .select('rotation_index,action_date').eq('id', 1).maybeSingle();
          if (stateReadErr) throw stateReadErr;
          // Upsert local state when the remote row is missing (null = fresh DB)
          // OR when local is ahead — rotationIndex is the primary tie-breaker.
          const localRotation  = local.rotationIndex ?? 0;
          const remoteRotation = remoteState ? (remoteState.rotation_index ?? 0) : -1;
          const localAhead =
            !remoteState ||
            localRotation > remoteRotation ||
            (localRotation === remoteRotation &&
             (local.actionDate || '') > (remoteState.action_date || ''));
          if (localAhead) {
            const { error: upsertErr } = await sb.from('state').upsert({
              id: 1,
              rotation_index: local.rotationIndex ?? 0,
              action_date:    local.actionDate    ?? null,
            });
            if (upsertErr) throw upsertErr;
          }
          // Insert the unsynced history entries
          const offlineRows = unsynced.map(e => ({
            type:     e.type,
            date:     e.date,
            advanced: e.advanced ?? true,
            note:     e.note ?? null,
            sequence: (local.history || []).indexOf(e),
          }));
          const { data: inserted, error: insErr } = await sb.from('history')
            .insert(offlineRows).select('id, sequence');
          if (insErr) throw insErr;
          // Match by sequence rather than array position — insert order is not
          // guaranteed to be preserved in the returned rows.
          inserted.forEach(row => {
            const match = unsynced.find((_, i) => offlineRows[i].sequence === row.sequence);
            if (match) match._sid = row.id;
          });
          localStorage.setItem(STORAGE_KEY, JSON.stringify(local));
        }
        // ────────────────────────────────────────────────────────────────────────

        const [stateRes, historyRes] = await Promise.all([
          sb.from('state').select('*').eq('id', 1).maybeSingle(),
          // Order by sequence (explicit insert order) rather than created_at so that
          // batch re-inserts — which share the same timestamp — come back in the
          // correct order.
          sb.from('history').select('*').order('sequence', { ascending: true, nullsFirst: true }),
        ]);
        if (stateRes.error) throw stateRes.error;
        if (historyRes.error) throw historyRes.error;

        const state = stateRes.data || {};
        const historyRows = historyRes.data || [];

        const data = {
          rotationIndex: state.rotation_index ?? 0,
          actionDate:    state.action_date   ?? null,
          history: historyRows.map(r => ({ type: r.type, date: r.date, advanced: r.advanced, note: r.note ?? undefined, _sid: r.id })),
        };

        // Derive each workout's last-done date from history
        for (const { type, date } of historyRows) {
          if (type !== 'off' && (!data[type] || date > data[type])) {
            data[type] = date;
          }
        }

        lastSyncedAt = Date.now();
        syncOffline  = false;
        updateSyncStamp();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); // keep local cache fresh
        return data;
      } catch (err) {
        console.warn('Supabase read failed, falling back to localStorage:', err);
        syncOffline = true;
        updateSyncStamp();
        try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; }
        catch { return {}; }
      }
    }

    async function saveData(data, deletedSid = null) {
      // Always write localStorage immediately so the fallback is always fresh
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      if (!sb || TEST_MODE) return; // localStorage-only or test mode — skip Supabase
      try {
        // Upsert the single state row (rotation position + today's lock)
        const { error: stateErr } = await sb.from('state').upsert({
          id: 1,
          rotation_index: data.rotationIndex ?? 0,
          action_date:    data.actionDate    ?? null,
        });
        if (stateErr) throw stateErr;

        // If this save was triggered by an undo, delete only that one row
        if (deletedSid) {
          const { error: delErr } = await sb.from('history').delete().eq('id', deletedSid);
          if (delErr) throw delErr;
        }

        // Insert only new entries — those not yet synced (no _sid means never written to Supabase)
        const newEntries = (data.history || []).filter(e => !e._sid);
        if (newEntries.length) {
          // sequence = the entry's position in the full history array, so ordering
          // by sequence always reproduces insertion order even across batch inserts
          // that share the same created_at timestamp.
          const rows = newEntries.map(e => ({
            type: e.type,
            date: e.date,
            advanced: e.advanced ?? true,
            note: e.note ?? null,
            sequence: data.history.indexOf(e),
          }));
          const { data: inserted, error: insErr } = await sb.from('history').insert(rows).select('id, sequence');
          if (insErr) throw insErr;
          // Match by sequence rather than array position — insert order is not
          // guaranteed to be preserved in the returned rows.
          const insertedBySeq = {};
          inserted.forEach(row => { insertedBySeq[row.sequence] = row.id; });
          newEntries.forEach(e => {
            const seq = data.history.indexOf(e);
            if (insertedBySeq[seq] !== undefined) e._sid = insertedBySeq[seq];
          });
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }
        lastSyncedAt = Date.now();
        syncOffline  = false;
        updateSyncStamp();
      } catch (err) {
        console.warn('Supabase write failed (data saved locally):', err);
        syncOffline = true;
        updateSyncStamp();
      }
    }

    function todayStr() {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    function getYesterdayStr() {
      const d = new Date();
      d.setDate(d.getDate() - 1);
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    function daysSince(dateStr) {
      if (!dateStr) return null;
      const [y, m, d] = dateStr.split('-').map(Number);
      const then = new Date(y, m - 1, d);
      const now = new Date();
      now.setHours(0, 0, 0, 0);
      return Math.round((now - then) / 86_400_000);
    }

    // Next workout is always the current rotation position
    function getSuggested(data) {
      const idx = (data.rotationIndex || 0) % ROTATION.length;
      return WORKOUTS.find(w => w.id === ROTATION[idx]);
    }

    function pillClass(days, doneToday) {
      if (doneToday)                  return 'today';
      if (days === null || days >= 6) return 'urgent';
      if (days >= 3)                  return 'warning';
      return 'ok';
    }

    function pillText(days, doneToday) {
      if (doneToday)     return 'Today';
      if (days === null) return 'Never';
      if (days === 1)    return '1 day';
      return `${days}d`;
    }

    function lastDoneText(days, doneToday) {
      if (doneToday)     return 'Completed today';
      if (days === null) return 'Never done';
      if (days === 1)    return 'Last done 1 day ago';
      return `Last done ${days} days ago`;
    }

    let toastTimer;
    function showToast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => el.classList.remove('show'), 1800);
    }

    // ── Double-tap guard ─────────────────────────────────────────────────────
    // Each action function sets this true at the start and false when complete
    // (via try/finally). Any tap that arrives during a network round-trip hits
    // the guard and returns immediately — no duplicate mutations.
    let isProcessing = false;
    let lastSyncedAt = null;  // Date.now() timestamp of last successful Supabase sync
    let syncOffline  = false; // true if the last Supabase attempt failed

    function setButtonsDisabled(disabled) {
      ['main-done-btn', 'skip-btn', 'log-other-btn', 'undo-btn'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = disabled;
      });
      document.querySelectorAll('.row-done-btn').forEach(el => {
        el.disabled = disabled;
      });
    }
    // ────────────────────────────────────────────────────────────────────────

    // Main "Done!" — logs the workout and advances the rotation
    async function markDone() {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const today = todayStr();
        const idx = (data.rotationIndex || 0) % ROTATION.length;
        const workoutId = ROTATION[idx];

        data[workoutId] = today;                              // keep last-done date for the UI
        data.rotationIndex = (idx + 1) % ROTATION.length;    // advance rotation
        data.actionDate = today;                              // lock today's card
        data.history = data.history || [];
        data.history.push({ type: workoutId, date: today, advanced: true });

        await saveData(data);
        render(data);
        showToast('Logged \u2713');
      } finally {
        isProcessing = false;
      }
    }

    // "Skip Today" — logs an off day, rotation stays put
    const SKIP_DEFAULTS = ['Sick', 'Travel', 'Vacation', 'Social obligation'];

    function openSkipModal() {
      const modal    = document.getElementById('skip-modal');
      const input    = document.getElementById('skip-reason-input');
      const chipsEl  = document.getElementById('skip-reason-chips');

      const saved = loadSkipReasons();
      const chips = saved.length ? saved : SKIP_DEFAULTS;

      chipsEl.innerHTML = '';
      for (const r of chips) {
        const chip = document.createElement('button');
        chip.className = 'activity-chip';
        chip.textContent = r;
        chip.type = 'button';
        chip.onclick = () => {
          input.value = r;
          setTimeout(() => input.focus(), 50);
        };
        chipsEl.appendChild(chip);
      }

      input.value = '';
      modal.hidden = false;
      setTimeout(() => input.focus(), 80);
    }

    function closeSkipModal() {
      document.getElementById('skip-modal').hidden = true;
    }

    async function logSkip(reason) {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        closeSkipModal();
        const data = await loadData();
        const today = todayStr();

        data.actionDate = today;
        data.history = data.history || [];
        const entry = { type: 'off', date: today, advanced: false };
        if (reason) entry.note = reason;
        data.history.push(entry);

        if (reason) saveSkipReason(reason);

        await saveData(data);
        render(data);
        showToast('Day off logged');
      } finally {
        isProcessing = false;
      }
    }

    // Undo — removes the most recent history entry if it's from today or yesterday
    async function undoLastEntry() {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const today = todayStr();
        const yesterday = getYesterdayStr();
        const history = data.history || [];
        if (!history.length) { render(data); return; }

        const last = history[history.length - 1];
        if (last.date !== today && last.date !== yesterday) { render(data); return; }

        const deletedSid = last._sid ?? null; // capture before removing so saveData can delete the right row

        // Remove the entry
        data.history = history.slice(0, -1);

        // Restore the previous last-done date for this workout type
        if (last.type !== 'off') {
          const prev = [...data.history].reverse().find(e => e.type === last.type);
          if (prev) {
            data[last.type] = prev.date;
          } else {
            delete data[last.type];
          }
        }

        // Roll back rotation if this entry advanced it.
        // New entries use advanced:true/false explicitly.
        // Old entries (no 'advanced' key) are assumed rotation-advancing if they're a workout,
        // since only markDone logged workouts before the advanced flag was introduced.
        const wasRotationAdvancing =
          last.advanced === true ||
          (!('advanced' in last) && last.type !== 'off');
        if (wasRotationAdvancing) {
          data.rotationIndex = ((data.rotationIndex || 0) - 1 + ROTATION.length) % ROTATION.length;
        }

        // Recalculate actionDate from what remains in history rather than guessing.
        // The card is locked today only if a rotation-advancing done or a skip still exists for today.
        const stillLockedToday = (data.history || []).some(e =>
          e.date === today && (
            e.advanced === true ||                          // new markDone entry
            e.type === 'off' ||                            // skip entry
            e.type === 'other' ||                          // other activity entry
            (!('advanced' in e) && e.type !== 'off')       // old entry without flag (backward compat)
          )
        );
        if (stillLockedToday) {
          data.actionDate = today;
        } else {
          delete data.actionDate;
        }

        await saveData(data, deletedSid);
        render(data);
        const name = last.type === 'off'
          ? 'day off'
          : last.type === 'other'
          ? (last.note || 'other activity')
          : (WORKOUTS.find(w => w.id === last.type)?.name ?? last.type);
        showToast(`Undone \u2014 ${name}`);
      } finally {
        isProcessing = false;
      }
    }

    // Row-level done — marks a specific workout without affecting the rotation
    async function markRowDone(id) {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const today = todayStr();

        data[id] = today;
        data.history = data.history || [];
        data.history.push({ type: id, date: today, advanced: false });

        await saveData(data);
        render(data);
        showToast('Logged \u2713');
      } finally {
        isProcessing = false;
      }
    }

    // ── HTML escape helper (prevents XSS when injecting user text into innerHTML)
    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    // ── Other Activity helpers ───────────────────────────────────────────────
    const OTHER_ACTIVITIES_KEY = TEST_MODE ? 'wmw_test_other_activities' : 'wmw_other_activities';
    const SKIP_REASONS_KEY = STORAGE_KEY + '_skip_reasons';

    function loadOtherActivities() {
      try {
        const parsed = JSON.parse(localStorage.getItem(OTHER_ACTIVITIES_KEY));
        if (typeof parsed === 'string') return [parsed];
        if (Array.isArray(parsed)) return parsed.filter(a => typeof a === 'string');
        return [];
      } catch { return []; }
    }

    function saveOtherActivities(name) {
      const existing = loadOtherActivities();
      const nameLower = name.toLowerCase();
      // Remove any existing entry that matches case-insensitively, then prepend
      const deduped = existing.filter(a => a.toLowerCase() !== nameLower);
      localStorage.setItem(OTHER_ACTIVITIES_KEY, JSON.stringify([name, ...deduped].slice(0, 10)));
    }

    function loadSkipReasons() {
      try {
        const parsed = JSON.parse(localStorage.getItem(SKIP_REASONS_KEY));
        if (typeof parsed === 'string') return [parsed];
        if (Array.isArray(parsed)) return parsed.filter(r => typeof r === 'string');
        return [];
      } catch { return []; }
    }

    function saveSkipReason(reason) {
      const existing = loadSkipReasons();
      const reasonLower = reason.toLowerCase();
      const deduped = existing.filter(r => r.toLowerCase() !== reasonLower);
      localStorage.setItem(SKIP_REASONS_KEY, JSON.stringify([reason, ...deduped].slice(0, 10)));
    }

    function openOtherActivityModal() {
      const modal      = document.getElementById('other-activity-modal');
      const input      = document.getElementById('other-activity-input');
      const chipsEl    = document.getElementById('other-activity-chips');
      const confirmBtn = document.getElementById('modal-confirm-btn');

      // Populate previous-activity chips
      chipsEl.innerHTML = '';
      for (const a of loadOtherActivities()) {
        const chip = document.createElement('button');
        chip.className = 'activity-chip';
        chip.textContent = a;
        chip.type = 'button';
        chip.onclick = () => {
          input.value = a;
          confirmBtn.disabled = false;
          setTimeout(() => input.focus(), 50);
        };
        chipsEl.appendChild(chip);
      }

      input.value = '';
      confirmBtn.disabled = true;
      modal.hidden = false;
      // Brief delay so the sheet animates into view before keyboard pops
      setTimeout(() => input.focus(), 80);
    }

    function closeOtherActivityModal() {
      document.getElementById('other-activity-modal').hidden = true;
    }

    const MAX_ACTIVITY_LENGTH = 100;

    async function logOtherActivity(activityName) {
      const name = String(activityName || '').trim().slice(0, MAX_ACTIVITY_LENGTH);
      if (!name || isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        closeOtherActivityModal();
        const data = await loadData();
        const today = todayStr();

        data.actionDate = today;
        data.history = data.history || [];
        data.history.push({ type: 'other', date: today, advanced: false, note: name });

        saveOtherActivities(name);

        await saveData(data);
        render(data);
        showToast(`${name} logged`);
      } finally {
        isProcessing = false;
      }
    }
    // ────────────────────────────────────────────────────────────────────────

    // ── Backfill Modal ───────────────────────────────────────────────────────
    // Lets the user log or edit a workout/rest/other for any past day.

    // All 7 selectable options shown in the modal
    const BACKFILL_OPTIONS = [
      ...WORKOUTS.map(w => ({ id: w.id, name: w.name, icon: w.icon, color: 'purple' })),
      { id: 'off',   name: 'Rest Day',       icon: 'moon', color: 'amber' },
      { id: 'other', name: 'Other Activity', icon: 'zap',  color: 'teal'  },
    ];

    const BF_WEEKDAYS = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
    const BF_MONTHS   = ['January','February','March','April','May','June',
                         'July','August','September','October','November','December'];

    let backfillDate     = null;  // 'YYYY-MM-DD' being edited
    let backfillExisting = null;  // existing history entry object, or null
    let backfillSelectedType = null; // currently selected option id
    let backfillSaving   = false; // true while confirmBackfill is awaiting

    function openBackfillModal(dateStr) {
      backfillDate = dateStr;

      // Find the most-recent logged entry for this date
      const history = cachedData ? (cachedData.history || []) : [];
      backfillExisting = [...history].reverse().find(e => e.date === dateStr) || null;

      // Build the date label: "Wednesday, February 19"
      const d = new Date(dateStr + 'T00:00:00');
      document.getElementById('backfill-date-label').textContent =
        `${BF_WEEKDAYS[d.getDay()]}, ${BF_MONTHS[d.getMonth()]} ${d.getDate()}`;

      if (backfillExisting) {
        // Entry exists — open in read-only mode
        _showBackfillReadonly(backfillExisting);
      } else {
        // No entry — open straight into edit/new mode
        backfillSelectedType = null;
        _showBackfillEdit(null);
      }

      document.getElementById('backfill-modal').hidden = false;
    }

    function closeBackfillModal() {
      if (backfillSaving) return; // don't dismiss while a save is in flight
      document.getElementById('backfill-modal').hidden = true;
      backfillDate     = null;
      backfillExisting = null;
      backfillSelectedType = null;
    }

    function _showBackfillReadonly(entry) {
      document.getElementById('backfill-readonly').hidden  = false;
      document.getElementById('backfill-edit-view').hidden = true;

      const isOff   = entry.type === 'off';
      const isOther = entry.type === 'other';
      const workout = (!isOff && !isOther) ? WORKOUTS.find(w => w.id === entry.type) : null;

      const iconName   = isOff ? 'moon' : isOther ? 'zap' : (workout ? workout.icon : 'dumbbell');
      const displayName = isOff   ? (entry.note || 'Rest Day') :
                          isOther ? (entry.note || 'Other Activity') :
                          (workout ? workout.name : entry.type);

      const iconEl = document.getElementById('backfill-readonly-icon');
      iconEl.className = 'backfill-readonly-icon' +
        (isOff ? ' is-rest' : isOther ? ' is-other' : '');
      iconEl.innerHTML = `<i data-lucide="${iconName}"></i>`;
      document.getElementById('backfill-readonly-name').textContent = displayName;

      if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    function _showBackfillEdit(preselectedType) {
      document.getElementById('backfill-readonly').hidden  = true;
      document.getElementById('backfill-edit-view').hidden = false;

      backfillSelectedType = preselectedType;
      _renderBackfillOptions(preselectedType);

      // Pre-fill the note input when editing an existing rest-day or other-activity entry
      const otherInput = document.getElementById('backfill-other-input');
      if ((preselectedType === 'other' || preselectedType === 'off') && backfillExisting?.note) {
        otherInput.value = backfillExisting.note;
      } else {
        otherInput.value = '';
      }

      _updateBackfillOtherSection(preselectedType === 'other' || preselectedType === 'off', preselectedType);
      _updateBackfillConfirmBtn();
    }

    function _renderBackfillOptions(selectedType) {
      const container = document.getElementById('backfill-options');
      container.innerHTML = '';

      for (const opt of BACKFILL_OPTIONS) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'backfill-option' +
          (opt.color === 'amber' ? ' is-rest'  : '') +
          (opt.color === 'teal'  ? ' is-other' : '') +
          (opt.id === selectedType ? ' selected' : '');
        btn.dataset.type = opt.id;

        const iconEl = document.createElement('i');
        iconEl.setAttribute('data-lucide', opt.icon);
        const nameEl = document.createElement('span');
        nameEl.textContent = opt.name;
        btn.appendChild(iconEl);
        btn.appendChild(nameEl);

        btn.onclick = () => _selectBackfillOption(opt.id);
        container.appendChild(btn);
      }

      if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    function _selectBackfillOption(type) {
      backfillSelectedType = type;

      // Toggle selected class on all option buttons
      document.querySelectorAll('.backfill-option').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.type === type);
      });

      _updateBackfillOtherSection(type === 'other' || type === 'off', type);
      _updateBackfillConfirmBtn();
    }

    function _updateBackfillOtherSection(show, type) {
      const section = document.getElementById('backfill-other-section');
      const input   = document.getElementById('backfill-other-input');
      section.hidden = !show;
      if (show) {
        // Placeholder and chips differ by type
        if (type === 'off') {
          input.placeholder = 'Reason (optional)';
          const saved = loadSkipReasons();
          const suggestions = saved.length ? saved : SKIP_DEFAULTS;
          const chipsEl = document.getElementById('backfill-other-chips');
          chipsEl.innerHTML = '';
          for (const r of suggestions) {
            const chip = document.createElement('button');
            chip.className = 'activity-chip';
            chip.textContent = r;
            chip.type = 'button';
            chip.onclick = () => {
              input.value = r;
              setTimeout(() => input.focus(), 50);
            };
            chipsEl.appendChild(chip);
          }
        } else {
          input.placeholder = 'Activity name (optional)';
          const chipsEl = document.getElementById('backfill-other-chips');
          chipsEl.innerHTML = '';
          for (const a of loadOtherActivities()) {
            const chip = document.createElement('button');
            chip.className = 'activity-chip';
            chip.textContent = a;
            chip.type = 'button';
            chip.onclick = () => {
              input.value = a;
              setTimeout(() => input.focus(), 50);
            };
            chipsEl.appendChild(chip);
          }
        }
        setTimeout(() => input.focus(), 80);
      }
    }

    function _updateBackfillConfirmBtn() {
      const btn = document.getElementById('backfill-confirm-btn');
      btn.disabled = !backfillSelectedType;
    }

    async function confirmBackfill() {
      if (!backfillDate || !backfillSelectedType || isProcessing) return;
      const otherInput = document.getElementById('backfill-other-input').value.trim();

      // Capture all shared mutable state into locals BEFORE any await so that
      // closeBackfillModal() (e.g. via an overlay tap during the network call)
      // cannot race and reset the module-level variables to null mid-save.
      const capturedDate     = backfillDate;
      const capturedType     = backfillSelectedType;
      const capturedExisting = backfillExisting;
      // Note is optional for both Rest Day and Other Activity; null if not entered
      const capturedNote     = (capturedType === 'other' || capturedType === 'off') && otherInput
        ? String(otherInput).slice(0, MAX_ACTIVITY_LENGTH)
        : null;

      isProcessing  = true;
      backfillSaving = true;
      const wasEdit = !!capturedExisting;

      try {
        const data    = await loadData();
        const history = data.history || [];

        const newType = capturedType;
        const note    = capturedNote;
        const dateStr = capturedDate;

        // Rotation advancement: only for workouts, only when this is the most-recent entry
        const isRotationWorkout = !!WORKOUTS.find(w => w.id === newType);
        const hasLaterEntries   = history.some(e => e.date > dateStr);
        const shouldAdvance     = isRotationWorkout && !hasLaterEntries;

        // Helper: recompute per-workout last-done dates from the full history.
        // Runs after any mutation so data.peloton etc. are never stale.
        function recomputeLastDone() {
          for (const w of WORKOUTS) {
            const maxDate = history
              .filter(e => e.type === w.id)
              .reduce((max, e) => (!max || e.date > max) ? e.date : max, null);
            if (maxDate) data[w.id] = maxDate;
            else delete data[w.id];
          }
        }

        if (capturedExisting) {
          // ── Edit existing entry ──────────────────────────────────────────────
          const wasAdvanced = capturedExisting.advanced === true;

          // Locate the entry in the (freshly loaded) history array
          const idx = capturedExisting._sid != null
            ? history.findIndex(e => e._sid === capturedExisting._sid)
            : history.findIndex(e =>
                e.date === dateStr &&
                e.type === capturedExisting.type &&
                !e._sid
              );

          if (idx !== -1) {
            history[idx].type     = newType;
            history[idx].advanced = shouldAdvance;
            if (note) { history[idx].note = note; }
            else      { delete history[idx].note; }
          }

          // Advance rotation only if this entry wasn't already counted
          if (shouldAdvance && !wasAdvanced) {
            data.rotationIndex = (data.rotationIndex || 0) + 1;
          }
          // Never decrement, even if the entry changed from workout → rest/other

          recomputeLastDone();
          data.history = history;
          await saveData(data);

          // Update the Supabase history row directly (saveData only inserts, not updates)
          if (sb && !TEST_MODE && capturedExisting._sid != null) {
            try {
              const { error } = await sb.from('history').update({
                type:     newType,
                note:     note || null,
                advanced: shouldAdvance,
              }).eq('id', capturedExisting._sid);
              if (error) console.warn('Supabase history update failed:', error);
            } catch (err) {
              console.warn('Supabase history update error:', err);
            }
          }
        } else {
          // ── New backfill entry ───────────────────────────────────────────────
          const newEntry = { type: newType, date: dateStr, advanced: shouldAdvance };
          if (note) newEntry.note = note;

          if (shouldAdvance) {
            data.rotationIndex = (data.rotationIndex || 0) + 1;
          }

          history.push(newEntry);
          recomputeLastDone();
          data.history = history;
          await saveData(data);
        }

        // Keep suggestion chip lists up to date
        if (newType === 'other' && note) saveOtherActivities(note);
        if (newType === 'off'   && note) saveSkipReason(note);

        cachedData = data;
        closeBackfillModal();

        // Re-render whichever history sub-view is visible
        renderCalendar(data);
        if (historyViewActive && historySubTab === 'list') renderHistoryList(data);

        const displayName = newType === 'off'   ? 'Rest day' :
                            newType === 'other'  ? (note || 'Other activity') :
                            (WORKOUTS.find(w => w.id === newType)?.name ?? newType);
        showToast(wasEdit ? `${displayName} updated` : `${displayName} logged`);

      } finally {
        isProcessing  = false;
        backfillSaving = false;
      }
    }
    // ────────────────────────────────────────────────────────────────────────

    // ── History view state ──────────────────────────────────────────────────
    let cachedData = null;        // last-loaded data, used by history renders
    let historyViewActive = false;
    let historySubTab = 'calendar'; // 'calendar' or 'list'
    let calViewDate = new Date(); // month currently shown in the calendar

    // Convert a Date object → 'YYYY-MM-DD' string (local time)
    function dateToStr(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    // Build a lookup map: dateStr → last history entry for that date
    function buildHistoryMap(data) {
      const map = {};
      for (const entry of (data.history || [])) {
        // Later entries override earlier ones for the same date
        map[entry.date] = entry;
      }
      return map;
    }

    // Project future workouts: starting from today (or the first un-logged day),
    // assign one rotation workout per calendar day going forward (up to 365 days).
    // data.rotationIndex already accounts for all past logged workouts.
    function buildProjectionMap(data) {
      const histMap = buildHistoryMap(data);
      const map = {};
      let rotIdx = data.rotationIndex || 0;
      const start = new Date();
      start.setHours(0, 0, 0, 0);

      for (let i = 0; i <= 365; i++) {
        const d = new Date(start);
        d.setDate(d.getDate() + i);
        const ds = dateToStr(d);
        // Only project days that have no actual logged data
        if (!histMap[ds]) {
          map[ds] = ROTATION[rotIdx % ROTATION.length];
          rotIdx = (rotIdx + 1) % ROTATION.length;
        }
      }
      return map;
    }

    // ── Calendar renderer ───────────────────────────────────────────────────
    function renderCalendar(data) {
      const container = document.getElementById('hview-calendar');
      const histMap = buildHistoryMap(data);
      const projMap = buildProjectionMap(data);
      const today = todayStr();

      const year  = calViewDate.getFullYear();
      const month = calViewDate.getMonth(); // 0-indexed

      const MONTH_NAMES = [
        'January','February','March','April','May','June',
        'July','August','September','October','November','December',
      ];

      const firstDayDow = new Date(year, month, 1).getDay();  // 0=Sun
      const daysInMonth = new Date(year, month + 1, 0).getDate();

      let html = `
        <div class="cal-header">
          <button class="cal-nav-btn" id="cal-prev-btn">
            <i data-lucide="chevron-left"></i>
          </button>
          <span class="cal-month-label">${MONTH_NAMES[month]} ${year}</span>
          <button class="cal-nav-btn" id="cal-next-btn">
            <i data-lucide="chevron-right"></i>
          </button>
        </div>
        <div class="cal-grid">
      `;

      // Day-of-week column headers
      for (const d of ['S','M','T','W','T','F','S']) {
        html += `<div class="cal-dow">${d}</div>`;
      }

      // Empty filler cells before the 1st of the month
      for (let i = 0; i < firstDayDow; i++) {
        html += '<div class="cal-day"></div>';
      }

      // One cell per day
      for (let day = 1; day <= daysInMonth; day++) {
        const ds = `${year}-${String(month + 1).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
        const isToday   = ds === today;
        const isFuture  = ds > today;
        const histEntry = histMap[ds];
        const projId    = projMap[ds]; // set for un-logged days >= today

        const isPast = ds < today;

        const classes = ['cal-day'];
        if (isToday)  classes.push('is-today');
        if (isPast)   classes.push('is-past');

        let iconHtml = '';

        if (histEntry) {
          // Actual logged data — show the real result
          if (histEntry.type === 'off') {
            classes.push('has-rest');
            iconHtml = '<i class="cal-icon" data-lucide="moon"></i>';
          } else if (histEntry.type === 'other') {
            classes.push('has-other');
            iconHtml = '<i class="cal-icon" data-lucide="zap"></i>';
          } else {
            classes.push('has-workout');
            const w = WORKOUTS.find(w => w.id === histEntry.type);
            if (w) iconHtml = `<i class="cal-icon" data-lucide="${w.icon}"></i>`;
          }
        } else if (projId) {
          // No log yet (today un-actioned or a future date) — show projected
          classes.push('is-projected');
          const w = WORKOUTS.find(w => w.id === projId);
          if (w) iconHtml = `<i class="cal-icon" data-lucide="${w.icon}"></i>`;
        }
        // Past days with no data: just the number, no icon

        const dateAttr = isPast ? ` data-date="${ds}" role="button" tabindex="0"` : '';
        html += `<div class="${classes.join(' ')}"${dateAttr}>${iconHtml}<span class="cal-day-num">${day}</span></div>`;
      }

      html += '</div>';
      container.innerHTML = html;

      // Past-day tap or keyboard activation → open backfill modal
      container.querySelectorAll('.cal-day.is-past[data-date]').forEach(cell => {
        cell.addEventListener('click', () => openBackfillModal(cell.dataset.date));
        cell.addEventListener('keydown', e => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            openBackfillModal(cell.dataset.date);
          }
        });
      });

      // Month navigation
      document.getElementById('cal-prev-btn').onclick = () => {
        calViewDate = new Date(calViewDate.getFullYear(), calViewDate.getMonth() - 1, 1);
        renderCalendar(data);
      };
      document.getElementById('cal-next-btn').onclick = () => {
        calViewDate = new Date(calViewDate.getFullYear(), calViewDate.getMonth() + 1, 1);
        renderCalendar(data);
      };

      if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    // ── History list renderer ───────────────────────────────────────────────
    function renderHistoryList(data) {
      const container = document.getElementById('hview-list');
      const today = todayStr();

      const MONTHS   = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const WEEKDAYS = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];

      // Build one row per history entry, most-recent first
      // Sort by date descending — YYYY-MM-DD strings compare correctly lexicographically,
      // so this is safe for both Supabase and localStorage data paths.
      const entries = [...(data.history || [])].sort((a, b) => b.date.localeCompare(a.date));

      // Build 14 future projected days (starting tomorrow)
      const projMap = buildProjectionMap(data);
      const futureRows = [];
      for (let i = 1; i <= 14; i++) {
        const d = new Date();
        d.setHours(0, 0, 0, 0);
        d.setDate(d.getDate() + i);
        const ds = dateToStr(d);
        if (projMap[ds]) futureRows.push({ date: ds, type: projMap[ds] });
      }

      // Helper: build one list row's HTML
      function rowHtml(dateStr, type, isProjected, isToday, note = null) {
        const d = new Date(dateStr + 'T00:00:00');
        const thisYear = new Date().getFullYear();
        const yearSuffix = d.getFullYear() !== thisYear ? `, ${d.getFullYear()}` : '';
        const dateMain = `${MONTHS[d.getMonth()]} ${d.getDate()}${yearSuffix}`;
        const dayName  = WEEKDAYS[d.getDay()];

        const isOff   = type === 'off';
        const isOther = type === 'other';
        const workout  = (isOff || isOther) ? null : WORKOUTS.find(w => w.id === type);
        const iconName = isOff ? 'moon' : isOther ? 'zap' : (workout ? workout.icon : 'dumbbell');
        const color    = isOff ? 'amber' : isOther ? 'teal' : 'purple';
        const dispName = isOff   ? 'Rest Day' :
                         isOther ? (note || 'Other Activity') :
                         (workout ? workout.name : type);

        const rowCls = [
          'hlist-row',
          isProjected ? 'is-projected' : '',
          isToday     ? 'is-today'     : '',
        ].filter(Boolean).join(' ');

        return `
          <div class="${rowCls}">
            <i class="hlist-icon ${color}" data-lucide="${iconName}"></i>
            <div class="hlist-date">
              <div class="hlist-date-main">${dateMain}</div>
              <div class="hlist-date-sub">${dayName}</div>
            </div>
            ${isOff && note
              ? `<div class="hlist-name-wrap">
                   <div class="hlist-name ${color}">${escapeHtml(dispName)}</div>
                   <div class="hlist-note">${escapeHtml(note)}</div>
                 </div>`
              : `<div class="hlist-name ${color}">${escapeHtml(dispName)}</div>`
            }
          </div>`;
      }

      let html = '';

      if (entries.length) {
        html += '<div class="hlist">';
        for (const e of entries) {
          html += rowHtml(e.date, e.type, false, e.date === today, e.note);
        }
        html += '</div>';
      } else {
        html += '<div class="hlist-empty">No workouts logged yet.</div>';
      }

      if (futureRows.length) {
        html += '<div class="hlist-section-label">Coming Up</div>';
        html += '<div class="hlist">';
        for (const r of futureRows) {
          html += rowHtml(r.date, r.type, true, false);
        }
        html += '</div>';
      }

      container.innerHTML = html;
      if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    // Decide which history sub-view to render
    function renderHistoryView(data) {
      if (historySubTab === 'calendar') renderCalendar(data);
      else renderHistoryList(data);
    }

    // ── Tab switching ───────────────────────────────────────────────────────
    function switchMainTab(tab) {
      historyViewActive = tab === 'history';
      document.getElementById('view-today').hidden   = historyViewActive;
      document.getElementById('view-history').hidden = !historyViewActive;
      document.getElementById('nav-today-btn').classList.toggle('active', !historyViewActive);
      document.getElementById('nav-history-btn').classList.toggle('active', historyViewActive);
      if (historyViewActive && cachedData) renderHistoryView(cachedData);
    }

    function switchHistorySubTab(tab) {
      historySubTab = tab;
      document.getElementById('htab-calendar').classList.toggle('active', tab === 'calendar');
      document.getElementById('htab-list').classList.toggle('active', tab === 'list');
      document.getElementById('hview-calendar').hidden = tab !== 'calendar';
      document.getElementById('hview-list').hidden     = tab !== 'list';
      if (cachedData) renderHistoryView(cachedData);
    }

    // ── Modal event listeners ───────────────────────────────────────────────
    // Tapping the dark overlay (outside the sheet) dismisses the modal
    document.getElementById('other-activity-modal').addEventListener('click', function (e) {
      if (e.target === this) closeOtherActivityModal();
    });
    document.getElementById('modal-cancel-btn').onclick = closeOtherActivityModal;
    document.getElementById('modal-confirm-btn').onclick = () => {
      const name = document.getElementById('other-activity-input').value.trim();
      if (name) logOtherActivity(name);
    };
    document.getElementById('other-activity-input').addEventListener('input', function () {
      document.getElementById('modal-confirm-btn').disabled = this.value.trim() === '';
    });
    document.getElementById('other-activity-input').addEventListener('keydown', function (e) {
      if (e.key === 'Enter') {
        const name = this.value.trim();
        if (name) logOtherActivity(name);
      }
    });

    // ── Skip modal event listeners ──────────────────────────────────────────
    document.getElementById('skip-modal').addEventListener('click', function (e) {
      if (e.target === this) closeSkipModal();
    });
    document.getElementById('skip-cancel-btn').onclick = closeSkipModal;
    document.getElementById('skip-confirm-btn').onclick = () => {
      const reason = document.getElementById('skip-reason-input').value.trim() || null;
      logSkip(reason);
    };
    document.getElementById('skip-reason-input').addEventListener('keydown', function (e) {
      if (e.key === 'Enter') {
        const reason = this.value.trim() || null;
        logSkip(reason);
      }
    });

    // ── Backfill modal event listeners ──────────────────────────────────────
    document.getElementById('backfill-modal').addEventListener('click', function (e) {
      if (e.target === this) closeBackfillModal();
    });
    document.getElementById('backfill-ro-close-btn').onclick = closeBackfillModal;
    document.getElementById('backfill-edit-btn').onclick = () => {
      _showBackfillEdit(backfillExisting ? backfillExisting.type : null);
    };
    document.getElementById('backfill-cancel-btn').onclick = () => {
      if (backfillExisting) {
        // Return to read-only view instead of closing
        _showBackfillReadonly(backfillExisting);
      } else {
        closeBackfillModal();
      }
    };
    document.getElementById('backfill-confirm-btn').onclick = confirmBackfill;
    document.getElementById('backfill-other-input').addEventListener('input', _updateBackfillConfirmBtn);
    document.getElementById('backfill-other-input').addEventListener('keydown', function (e) {
      if (e.key === 'Enter' && !document.getElementById('backfill-confirm-btn').disabled) {
        confirmBackfill();
      }
    });

    // ── Nav event listeners ─────────────────────────────────────────────────
    document.getElementById('nav-today-btn').onclick   = () => switchMainTab('today');
    document.getElementById('nav-history-btn').onclick = () => switchMainTab('history');
    document.getElementById('htab-calendar').onclick   = () => switchHistorySubTab('calendar');
    document.getElementById('htab-list').onclick       = () => switchHistorySubTab('list');

    // ── Main render ─────────────────────────────────────────────────────────
    async function render(preloadedData = null) {
      const data = preloadedData || await loadData();
      cachedData = data; // cache so history renderers can access it on-demand

      const today = todayStr();
      const nextInRotation = getSuggested(data);
      const actionTakenToday = data.actionDate === today;

      // What specifically happened today (if anything)
      const todayEntry = [...(data.history || [])].reverse().find(e => e.date === today);
      const skippedToday = todayEntry?.type === 'off';
      const otherToday   = todayEntry?.type === 'other';

      // Hero card stays on the completed workout for the rest of the day.
      // Only flip to the next rotation item when a new day begins.
      const heroWorkout = (actionTakenToday && !skippedToday && !otherToday && todayEntry)
        ? (WORKOUTS.find(w => w.id === todayEntry.type) || nextInRotation)
        : nextInRotation;

      // Date label
      document.getElementById('date-label').textContent = new Date().toLocaleDateString(
        undefined, { weekday: 'long', month: 'long', day: 'numeric' }
      );

      // ── Hero card — four distinct states ─────────────────────────────────
      // 'default'  = nothing logged today → Done! + Skip + Other visible, Undo hidden
      // 'done'     = workout completed today → Undo visible, action buttons hidden
      // 'skipped'  = rest day logged today  → Undo visible, action buttons hidden
      // 'other'    = other activity logged  → Undo visible, action buttons hidden
      const history = data.history || [];
      // Derive state from todayEntry (the source of truth), not actionTakenToday.
      // actionDate and history can drift out of sync on a partial Supabase write,
      // so using todayEntry prevents a false 'done' state with no actual log entry.
      const heroState = skippedToday ? 'skipped' : otherToday ? 'other' : (todayEntry ? 'done' : 'default');
      const sugDays = data[heroWorkout.id] ? daysSince(data[heroWorkout.id]) : null;

      // Eyebrow label
      document.getElementById('suggestion-eyebrow').textContent =
        heroState === 'done'    ? 'Completed'      :
        heroState === 'skipped' ? 'Day Off'        :
        heroState === 'other'   ? 'Other Activity' : 'Next Up';

      // Icon — rebuild the inner element so lucide picks up the change each render
      const heroIconWrap = document.getElementById('hero-icon-wrap');
      const heroIconName =
        heroState === 'skipped' ? 'moon' :
        heroState === 'other'   ? 'zap'  : heroWorkout.icon;
      heroIconWrap.className = 'hero-icon-wrap' +
        (heroState === 'skipped' ? ' is-rest' : heroState === 'other' ? ' is-other' : '');
      heroIconWrap.innerHTML = `<i data-lucide="${heroIconName}"></i>`;

      // Name
      document.getElementById('suggestion-name').textContent =
        heroState === 'skipped' ? 'Rest Day' :
        heroState === 'other'   ? (todayEntry?.note || 'Other Activity') :
        heroWorkout.name;

      // Subtitle
      document.getElementById('suggestion-subtitle').textContent =
        heroState === 'done'    ? 'Completed today'       :
        heroState === 'skipped' ? 'Day off logged'        :
        heroState === 'other'   ? 'Other activity logged' :
                                   lastDoneText(sugDays, false);

      // Buttons — mutually exclusive per state
      const mainBtn      = document.getElementById('main-done-btn');
      const skipBtn      = document.getElementById('skip-btn');
      const logOtherBtn  = document.getElementById('log-other-btn');
      const undoBtn      = document.getElementById('undo-btn');

      // Re-enable all hero buttons: setButtonsDisabled(true) fires at the start of
      // every action and is never explicitly reversed — render() is the natural
      // place to restore interactive state after a round-trip completes.
      mainBtn.disabled     = false;
      skipBtn.disabled     = false;
      logOtherBtn.disabled = false;
      undoBtn.disabled     = false;

      mainBtn.hidden     = heroState !== 'default';
      skipBtn.hidden     = heroState !== 'default';
      logOtherBtn.hidden = heroState !== 'default';

      if (heroState === 'default') {
        mainBtn.onclick    = markDone;
        skipBtn.onclick    = openSkipModal;
        logOtherBtn.onclick = openOtherActivityModal;
        undoBtn.hidden = true;
      } else {
        // Undo button with lucide icon (no iOS emoji arrow)
        const undoLabel =
          heroState === 'skipped' ? 'Rest Day' :
          heroState === 'other'   ? (todayEntry?.note || 'Other Activity') :
          heroWorkout.name;
        undoBtn.innerHTML = '';
        const undoIcon = document.createElement('i');
        undoIcon.setAttribute('data-lucide', 'undo-2');
        undoBtn.appendChild(undoIcon);
        undoBtn.appendChild(document.createTextNode(`Undo ${undoLabel}`));
        undoBtn.onclick = undoLastEntry;
        undoBtn.hidden = false;
      }

      // Tomorrow row — one step ahead of whatever is currently next
      // If action was taken today, rotation already advanced so nextInRotation IS tomorrow.
      // If today hasn't been actioned yet, rotation still points to today, so add 1.
      const tomorrowWorkout = actionTakenToday
        ? nextInRotation
        : WORKOUTS.find(w => w.id === ROTATION[((data.rotationIndex || 0) + 1) % ROTATION.length]);
      const tomorrowNameEl = document.getElementById('tomorrow-name');
      tomorrowNameEl.innerHTML = '';
      const tomorrowIconEl = document.createElement('i');
      tomorrowIconEl.setAttribute('data-lucide', tomorrowWorkout.icon);
      tomorrowIconEl.className = 'tomorrow-icon';
      tomorrowNameEl.appendChild(tomorrowIconEl);
      tomorrowNameEl.appendChild(document.createTextNode(tomorrowWorkout.name));

      // Workout list — suggested first, then by most recently done
      const sorted = [...WORKOUTS].sort((a, b) => {
        if (a.id === nextInRotation.id) return -1;
        if (b.id === nextInRotation.id) return 1;
        const doneA = data[a.id] === today;
        const doneB = data[b.id] === today;
        const daysA = data[a.id] ? daysSince(data[a.id]) : null;
        const daysB = data[b.id] ? daysSince(data[b.id]) : null;
        const scoreA = doneA ? -1 : (daysA === null ? Infinity : daysA);
        const scoreB = doneB ? -1 : (daysB === null ? Infinity : daysB);
        return scoreB - scoreA;
      });

      const list = document.getElementById('workout-list');
      list.innerHTML = '';

      for (const w of sorted) {
        const last = data[w.id];
        const days = last ? daysSince(last) : null;
        const doneToday = last === today;
        const isSuggested = w.id === nextInRotation.id;

        const row = document.createElement('div');
        row.className = [
          'workout-row',
          isSuggested ? 'is-suggested' : '',
          doneToday   ? 'done-today'   : '',
        ].filter(Boolean).join(' ');

        const info = document.createElement('div');
        info.className = 'workout-info';

        const nameEl = document.createElement('div');
        nameEl.className = 'workout-name';
        const rowIconEl = document.createElement('i');
        rowIconEl.setAttribute('data-lucide', w.icon);
        rowIconEl.className = 'row-icon';
        const nameSpan = document.createElement('span');
        nameSpan.textContent = w.name;
        nameEl.appendChild(rowIconEl);
        nameEl.appendChild(nameSpan);

        const lastEl = document.createElement('div');
        lastEl.className = 'workout-last';
        lastEl.textContent = lastDoneText(days, doneToday);

        info.appendChild(nameEl);
        info.appendChild(lastEl);

        const pill = document.createElement('span');
        pill.className = 'days-pill ' + pillClass(days, doneToday);
        pill.textContent = pillText(days, doneToday);

        const btn = document.createElement('button');
        btn.className = 'row-done-btn';
        btn.textContent = doneToday ? '\u2713' : 'Done';
        btn.disabled = doneToday;
        if (!doneToday) btn.onclick = () => markRowDone(w.id);

        row.appendChild(info);
        row.appendChild(pill);
        row.appendChild(btn);
        list.appendChild(row);
      }

      // If the history view is visible, keep it in sync with the new data
      if (historyViewActive) renderHistoryView(data);

      // Replace all data-lucide placeholder elements with SVG icons
      if (typeof lucide !== 'undefined') lucide.createIcons();

    }

    // ── Test mode banner ─────────────────────────────────────────────────────
    if (TEST_MODE) {
      document.getElementById('test-banner').hidden = false;
      document.getElementById('test-reset-btn').onclick = () => {
        localStorage.removeItem(STORAGE_KEY);
        localStorage.removeItem(OTHER_ACTIVITIES_KEY);
        localStorage.removeItem(SKIP_REASONS_KEY);
        render();
      };
      document.getElementById('test-exit-btn').onclick = toggleTestMode;
    }
    // ────────────────────────────────────────────────────────────────────────

    // ── Version stamp + sync status ───────────────────────────────────────────
    function updateSyncStamp() {
      const el = document.getElementById('version-stamp');
      let status = '';
      if (syncOffline) {
        status = 'offline';
      } else if (lastSyncedAt !== null) {
        const secsAgo = Math.floor((Date.now() - lastSyncedAt) / 1000);
        status = secsAgo < 60 ? 'synced just now' : `synced ${Math.floor(secsAgo / 60)}m ago`;
      }
      el.textContent = status ? `v${VERSION} · ${status}` : `v${VERSION}`;
    }
    updateSyncStamp();
    setInterval(updateSyncStamp, 30_000);

    function toggleTestMode() {
      const url = new URL(window.location.href);
      if (url.searchParams.get('test') === 'true') {
        url.searchParams.delete('test');
      } else {
        url.searchParams.set('test', 'true');
      }
      window.location.href = url.toString();
    }

    // Triple-tap within 600 ms to toggle test mode
    let _tapCount = 0;
    let _tapTimer = null;
    document.getElementById('version-stamp').addEventListener('click', () => {
      _tapCount++;
      if (_tapCount === 3) {
        _tapCount = 0;
        clearTimeout(_tapTimer);
        toggleTestMode();
        return;
      }
      clearTimeout(_tapTimer);
      _tapTimer = setTimeout(() => { _tapCount = 0; }, 600);
    });

    // Alt+Shift+T (desktop) — same toggle (Ctrl+Shift+T is reserved by browsers)
    document.addEventListener('keydown', e => {
      if (e.altKey && e.shiftKey && e.key === 'T') toggleTestMode();
    });
    // ──────────────────────────────────────────────────────────────────────────

    render();

  }); // end DOMContentLoaded

  // Register service worker outside DOMContentLoaded so it starts as early as
  // possible — it does not depend on the Supabase client.
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js').catch(() => {});
    });
  }
  </script>
</body>
</html>
