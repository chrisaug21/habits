<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>What's My Workout?</title>

  <!-- PWA -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#0d0d14">
  <!-- iOS standalone mode -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="My Workout">
  <link rel="icon" href="/favicon.ico" sizes="48x48">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <!-- Supabase JS client — defer so it doesn't block page render; crossorigin for SW caching -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2" defer crossorigin="anonymous"></script>
  <!-- Lucide Icons — defer matches Supabase script; crossorigin for SW caching -->
  <script src="https://cdn.jsdelivr.net/npm/lucide@0.563.0/dist/umd/lucide.min.js" defer crossorigin="anonymous"></script>
  <style>
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg: #0d0d14;
      --surface: #13131e;
      --surface2: #1a1a28;
      --border: #222235;
      --border-active: #4040a0;
      --accent: #6c63ff;
      --accent-dark: #4a42cc;
      --text-primary: #e4e4f4;
      --text-secondary: #6a6a90;
      --text-dim: #3a3a58;
      --red: #ff5555;
      --orange: #ff9944;
      --green: #3ecf8e;
      --amber: #f59e0b;
      --red-bg: #2a0f0f;
      --orange-bg: #2a1a0a;
      --green-bg: #0a2018;
    }

    html {
      background: var(--bg);
    }

    body {
      background: var(--bg);
      color: var(--text-primary);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      min-height: 100vh;
      min-height: 100dvh;
      padding: env(safe-area-inset-top, 0) 0 0;
      -webkit-font-smoothing: antialiased;
    }

    .container {
      max-width: 500px;
      margin: 0 auto;
      /* Extra bottom padding so content scrolls above the fixed bottom nav */
      padding: 24px 16px calc(80px + env(safe-area-inset-bottom, 0px));
    }

    /* Header */
    header {
      text-align: center;
      margin-bottom: 28px;
    }

    header h1 {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-secondary);
      letter-spacing: 0.04em;
    }

    /* Today's date */
    .date-label {
      font-size: 0.72rem;
      color: var(--text-dim);
      margin-top: 4px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    /* Suggestion card */
    .suggestion-card {
      background: var(--surface2);
      border: 1px solid var(--border-active);
      border-radius: 22px;
      padding: 32px 24px 28px;
      margin-bottom: 28px;
      text-align: center;
      position: relative;
      overflow: hidden;
    }

    .suggestion-card::before {
      content: '';
      position: absolute;
      top: -40px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 200px;
      background: radial-gradient(circle, rgba(108, 99, 255, 0.12) 0%, transparent 70%);
      pointer-events: none;
    }

    .suggestion-eyebrow {
      font-size: 0.68rem;
      font-weight: 700;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--accent);
      margin-bottom: 12px;
    }

    .suggestion-name {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--text-primary);
      line-height: 1.15;
      margin-bottom: 8px;
      letter-spacing: -0.02em;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }

    .suggestion-name .hero-icon {
      display: block;
      width: 48px;
      height: 48px;
      color: var(--accent);
      flex-shrink: 0;
      /* align-items:center uses geometric box centers, but the visual center of
         large cap text sits below the box midpoint due to descender/baseline space.
         Shift the icon down to optically align with the text's cap-height center. */
      transform: translateY(8px);
    }

    .suggestion-subtitle {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 28px;
    }

    .done-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 16px;
      padding: 18px 48px;
      font-size: 1.05rem;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s, opacity 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      min-width: 180px;
    }

    .done-btn:active {
      background: var(--accent-dark);
      transform: scale(0.96);
    }

    .done-btn:disabled {
      background: var(--surface);
      color: var(--text-secondary);
      cursor: default;
      border: 1px solid var(--border);
    }

    .done-btn:disabled:active {
      transform: none;
    }

    .card-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .skip-btn {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 11px 28px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      min-width: 180px;
    }

    .skip-btn:active {
      background: var(--surface);
    }

    .skip-btn:disabled {
      opacity: 0.35;
      cursor: default;
    }

    .skip-btn:disabled:active {
      background: transparent;
    }

    /* Undo button */
    .undo-btn {
      background: transparent;
      border: none;
      color: var(--text-dim);
      font-size: 0.78rem;
      font-weight: 600;
      cursor: pointer;
      padding: 8px 16px;
      border-radius: 8px;
      transition: color 0.15s, background 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .undo-btn:active {
      color: var(--text-secondary);
      background: var(--surface);
    }

    /* Log for yesterday link inside each workout row */
    .log-yesterday-link {
      display: inline-block;
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 0.72rem;
      font-weight: 500;
      cursor: pointer;
      padding: 3px 0 0;
      margin-top: 1px;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      text-align: left;
    }

    .log-yesterday-link:active {
      color: var(--text-secondary);
    }

    /* Workout list */
    .list-header {
      font-size: 0.68rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-dim);
      margin-bottom: 10px;
      padding: 0 4px;
    }

    .workout-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .workout-row {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px 16px 16px 18px;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: border-color 0.2s, opacity 0.2s;
    }

    .workout-row.is-suggested {
      border-color: rgba(108, 99, 255, 0.4);
    }

    .workout-row.done-today {
      opacity: 0.45;
    }

    .workout-info {
      flex: 1;
      min-width: 0;
    }

    .workout-name {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 3px;
      display: flex;
      align-items: center;
      gap: 7px;
    }

    .workout-name span {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Workout type icons */
    .row-icon {
      flex-shrink: 0;
      width: 15px;
      height: 15px;
      color: var(--text-secondary);
    }

    .workout-last {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    /* Days pill */
    .days-pill {
      font-size: 0.78rem;
      font-weight: 700;
      padding: 5px 11px;
      border-radius: 20px;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .days-pill.urgent   { background: var(--red-bg);    color: var(--red);    }
    .days-pill.warning  { background: var(--orange-bg); color: var(--orange); }
    .days-pill.ok       { background: var(--green-bg);  color: var(--green);  }
    .days-pill.today    { background: var(--green-bg);  color: var(--green);  }

    /* Row done button */
    .row-done-btn {
      background: transparent;
      color: var(--text-secondary);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 9px 14px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      white-space: nowrap;
      flex-shrink: 0;
      transition: background 0.15s, border-color 0.15s, color 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      min-width: 56px;
    }

    .row-done-btn:active {
      background: var(--surface2);
    }

    .row-done-btn:disabled {
      opacity: 0.4;
      cursor: default;
    }

    /* Tomorrow preview */
    .tomorrow-preview {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px 20px 18px;
      margin-bottom: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      text-align: center;
    }

    .tomorrow-label {
      font-size: 0.68rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-dim);
    }

    .tomorrow-name {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 7px;
    }

    .tomorrow-name .tomorrow-icon {
      width: 16px;
      height: 16px;
      color: var(--text-secondary);
      flex-shrink: 0;
    }

    /* Toast — raised above the bottom nav bar */
    .toast {
      position: fixed;
      bottom: calc(72px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: var(--surface2);
      border: 1px solid var(--border-active);
      color: var(--text-primary);
      padding: 13px 26px;
      border-radius: 14px;
      font-size: 0.9rem;
      font-weight: 600;
      pointer-events: none;
      opacity: 0;
      transition: transform 0.28s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
      white-space: nowrap;
      z-index: 100;
    }

    .toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* ── Bottom Navigation ─────────────────────────────────────────────────── */
    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--surface);
      border-top: 1px solid var(--border);
      display: flex;
      z-index: 50;
      /* Push visible content above the iPhone home bar */
      padding-bottom: env(safe-area-inset-bottom, 0px);
    }

    .nav-btn {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 10px 0;
      min-height: 56px;
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 0.62rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      transition: color 0.15s;
    }

    .nav-btn.active {
      color: var(--accent);
    }

    /* Target both the placeholder <i> and the SVG lucide generates */
    .nav-btn i,
    .nav-btn svg {
      width: 22px;
      height: 22px;
    }

    /* ── History view ──────────────────────────────────────────────────────── */

    /* Sub-tab row: Calendar / List toggle */
    .history-tabs {
      display: flex;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 4px;
      margin-bottom: 20px;
    }

    .htab {
      flex: 1;
      padding: 10px;
      background: none;
      border: none;
      border-radius: 10px;
      color: var(--text-secondary);
      font-size: 0.88rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .htab.active {
      background: var(--surface2);
      color: var(--accent);
    }

    /* ── Calendar ──────────────────────────────────────────────────────────── */
    .cal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .cal-month-label {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-primary);
    }

    .cal-nav-btn {
      background: none;
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-secondary);
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      transition: background 0.15s, color 0.15s;
    }

    .cal-nav-btn:active {
      background: var(--surface2);
      color: var(--text-primary);
    }

    .cal-nav-btn i,
    .cal-nav-btn svg {
      width: 16px;
      height: 16px;
    }

    .cal-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 3px;
    }

    .cal-dow {
      text-align: center;
      font-size: 0.6rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-dim);
      padding: 2px 0 8px;
    }

    .cal-day {
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      border-radius: 8px;
    }

    .cal-day.is-today {
      background: rgba(108, 99, 255, 0.12);
      outline: 1px solid rgba(108, 99, 255, 0.35);
    }

    /* Day number inside each cell */
    .cal-day-num {
      font-size: 0.68rem;
      font-weight: 600;
      color: var(--text-dim);
      line-height: 1;
    }

    .cal-day.is-today .cal-day-num {
      color: var(--text-primary);
      font-weight: 700;
    }

    /* Cells with actual logged data get a slightly brighter number */
    .cal-day.has-workout .cal-day-num,
    .cal-day.has-rest .cal-day-num {
      color: var(--text-secondary);
    }

    /* Small icon inside calendar cells */
    .cal-icon,
    .cal-day svg {
      width: 13px;
      height: 13px;
    }

    .cal-day.has-workout .cal-icon,
    .cal-day.has-workout svg {
      color: var(--accent);
    }

    .cal-day.has-rest .cal-icon,
    .cal-day.has-rest svg {
      color: var(--amber);
    }

    /* Projected future days: dimmed icon */
    .cal-day.is-projected .cal-icon,
    .cal-day.is-projected svg {
      color: var(--text-dim);
      opacity: 0.7;
    }

    /* ── History List ──────────────────────────────────────────────────────── */
    .hlist {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .hlist-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 14px;
    }

    .hlist-row.is-today {
      border-color: rgba(108, 99, 255, 0.4);
      background: var(--surface2);
    }

    /* Projected rows are faded */
    .hlist-row.is-projected {
      opacity: 0.4;
    }

    .hlist-icon {
      flex-shrink: 0;
      width: 16px;
      height: 16px;
      color: var(--text-dim);
    }

    .hlist-icon.purple { color: var(--accent); }
    .hlist-icon.amber  { color: var(--amber); }

    .hlist-date {
      flex: 1;
      min-width: 0;
    }

    .hlist-date-main {
      font-size: 0.82rem;
      font-weight: 700;
      color: var(--text-primary);
      line-height: 1.2;
    }

    .hlist-date-sub {
      font-size: 0.7rem;
      color: var(--text-secondary);
      margin-top: 1px;
    }

    .hlist-name {
      font-size: 0.78rem;
      font-weight: 600;
      color: var(--text-secondary);
      text-align: right;
      flex-shrink: 0;
      max-width: 52%;
    }

    .hlist-name.purple { color: var(--text-primary); }
    .hlist-name.amber  { color: var(--amber); }

    .hlist-section-label {
      font-size: 0.62rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-dim);
      padding: 20px 4px 8px;
    }

    .hlist-empty {
      text-align: center;
      color: var(--text-dim);
      font-size: 0.85rem;
      padding: 48px 0 24px;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>What's My Workout?</h1>
      <div class="date-label" id="date-label"></div>
    </header>

    <!-- ── Today view ─────────────────────────────────────────────────────── -->
    <div id="view-today">
      <div class="suggestion-card" id="suggestion-card">
        <div class="suggestion-eyebrow">Next Up</div>
        <div class="suggestion-name" id="suggestion-name"></div>
        <div class="suggestion-subtitle" id="suggestion-subtitle"></div>
        <div class="card-actions">
          <button class="done-btn" id="main-done-btn">Done!</button>
          <button class="skip-btn" id="skip-btn">Skip Today</button>
          <button class="undo-btn" id="undo-btn" hidden></button>
        </div>
      </div>

      <div class="tomorrow-preview">
        <span class="tomorrow-label">Tomorrow</span>
        <span class="tomorrow-name" id="tomorrow-name"></span>
      </div>

      <div class="list-header">All Workouts</div>
      <div class="workout-list" id="workout-list"></div>
    </div>

    <!-- ── History view ───────────────────────────────────────────────────── -->
    <div id="view-history" hidden>
      <div class="history-tabs">
        <button class="htab active" id="htab-calendar">Calendar</button>
        <button class="htab" id="htab-list">List</button>
      </div>
      <div id="hview-calendar"></div>
      <div id="hview-list" hidden></div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- ── Bottom Navigation ──────────────────────────────────────────────── -->
  <nav class="bottom-nav">
    <button class="nav-btn active" id="nav-today-btn">
      <i data-lucide="dumbbell"></i>
      <span>Today</span>
    </button>
    <button class="nav-btn" id="nav-history-btn">
      <i data-lucide="calendar"></i>
      <span>History</span>
    </button>
  </nav>

  <script>
  // DOMContentLoaded ensures the deferred Supabase CDN script has executed before
  // app initialisation runs. Without this wrapper, the inline script would run
  // during HTML parsing — before the deferred script — and window.supabase
  // would be undefined.
  document.addEventListener('DOMContentLoaded', function () {

    // ── Supabase config ──────────────────────────────────────────────────────
    const SUPABASE_URL = '%%SUPABASE_URL%%';
    const SUPABASE_KEY = '%%SUPABASE_KEY%%';
    let sb = null;
    try {
      sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    } catch (e) {
      console.warn('Supabase unavailable; running in localStorage-only mode.', e);
    }
    // ────────────────────────────────────────────────────────────────────────

    const WORKOUTS = [
      { id: 'peloton',    name: 'Cardio \u2014 Peloton Ride',    icon: 'bike'            },
      { id: 'upper_push', name: 'Strength \u2014 Upper Push',    icon: 'dumbbell'        },
      { id: 'upper_pull', name: 'Strength \u2014 Upper Pull',    icon: 'dumbbell'        },
      { id: 'lower',      name: 'Strength \u2014 Lower Body',    icon: 'dumbbell'        },
      { id: 'yoga',       name: 'Flexibility \u2014 Yoga',       icon: 'flower-2'        },
    ];

    // Fixed rotation: Peloton every other slot, Yoga every 4th workout overall
    const ROTATION = [
      'peloton', 'upper_push',
      'peloton', 'yoga',
      'peloton', 'upper_pull',
      'peloton', 'yoga',
      'peloton', 'lower',
      'peloton', 'yoga',
    ];

    const STORAGE_KEY = 'wmw_v1';

    async function loadData() {
      if (!sb) {
        try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; }
        catch { return {}; }
      }
      try {
        const [stateRes, historyRes] = await Promise.all([
          sb.from('state').select('*').eq('id', 1).maybeSingle(),
          // Order by sequence (explicit insert order) rather than created_at so that
          // batch re-inserts — which share the same timestamp — come back in the
          // correct order.
          sb.from('history').select('*').order('sequence', { ascending: true, nullsFirst: true }),
        ]);
        if (stateRes.error) throw stateRes.error;
        if (historyRes.error) throw historyRes.error;

        const state = stateRes.data || {};
        const historyRows = historyRes.data || [];

        const data = {
          rotationIndex: state.rotation_index ?? 0,
          actionDate:    state.action_date   ?? null,
          history: historyRows.map(r => ({ type: r.type, date: r.date, advanced: r.advanced, _sid: r.id })),
        };

        // Derive each workout's last-done date from history
        for (const { type, date } of historyRows) {
          if (type !== 'off' && (!data[type] || date > data[type])) {
            data[type] = date;
          }
        }

        localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); // keep local cache fresh
        return data;
      } catch (err) {
        console.warn('Supabase read failed, falling back to localStorage:', err);
        try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; }
        catch { return {}; }
      }
    }

    async function saveData(data, deletedSid = null) {
      // Always write localStorage immediately so the fallback is always fresh
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      if (!sb) return; // localStorage-only mode (Supabase client unavailable)
      try {
        // Upsert the single state row (rotation position + today's lock)
        const { error: stateErr } = await sb.from('state').upsert({
          id: 1,
          rotation_index: data.rotationIndex ?? 0,
          action_date:    data.actionDate    ?? null,
        });
        if (stateErr) throw stateErr;

        // If this save was triggered by an undo, delete only that one row
        if (deletedSid) {
          const { error: delErr } = await sb.from('history').delete().eq('id', deletedSid);
          if (delErr) throw delErr;
        }

        // Insert only new entries — those not yet synced (no _sid means never written to Supabase)
        const newEntries = (data.history || []).filter(e => !e._sid);
        if (newEntries.length) {
          // sequence = the entry's position in the full history array, so ordering
          // by sequence always reproduces insertion order even across batch inserts
          // that share the same created_at timestamp.
          const rows = newEntries.map(e => ({
            type: e.type,
            date: e.date,
            advanced: e.advanced ?? true,
            sequence: data.history.indexOf(e),
          }));
          const { data: inserted, error: insErr } = await sb.from('history').insert(rows).select('id');
          if (insErr) throw insErr;
          // Store the Supabase-assigned IDs back so future saves know these rows exist
          inserted.forEach((row, i) => { newEntries[i]._sid = row.id; });
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }
      } catch (err) {
        console.warn('Supabase write failed (data saved locally):', err);
      }
    }

    function todayStr() {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    function getYesterdayStr() {
      const d = new Date();
      d.setDate(d.getDate() - 1);
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    function daysSince(dateStr) {
      if (!dateStr) return null;
      const [y, m, d] = dateStr.split('-').map(Number);
      const then = new Date(y, m - 1, d);
      const now = new Date();
      now.setHours(0, 0, 0, 0);
      return Math.round((now - then) / 86_400_000);
    }

    // Next workout is always the current rotation position
    function getSuggested(data) {
      const idx = (data.rotationIndex || 0) % ROTATION.length;
      return WORKOUTS.find(w => w.id === ROTATION[idx]);
    }

    function pillClass(days, doneToday) {
      if (doneToday)                  return 'today';
      if (days === null || days >= 6) return 'urgent';
      if (days >= 3)                  return 'warning';
      return 'ok';
    }

    function pillText(days, doneToday) {
      if (doneToday)     return 'Today';
      if (days === null) return 'Never';
      if (days === 1)    return '1 day';
      return `${days}d`;
    }

    function lastDoneText(days, doneToday) {
      if (doneToday)     return 'Completed today';
      if (days === null) return 'Never done';
      if (days === 1)    return 'Last done 1 day ago';
      return `Last done ${days} days ago`;
    }

    let toastTimer;
    function showToast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => el.classList.remove('show'), 1800);
    }

    // ── Double-tap guard ─────────────────────────────────────────────────────
    // Each action function sets this true at the start and false when complete
    // (via try/finally). Any tap that arrives during a network round-trip hits
    // the guard and returns immediately — no duplicate mutations.
    let isProcessing = false;

    function setButtonsDisabled(disabled) {
      ['main-done-btn', 'skip-btn', 'undo-btn'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = disabled;
      });
      document.querySelectorAll('.row-done-btn, .log-yesterday-link').forEach(el => {
        el.disabled = disabled;
      });
    }
    // ────────────────────────────────────────────────────────────────────────

    // Main "Done!" — logs the workout and advances the rotation
    async function markDone() {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const today = todayStr();
        const idx = (data.rotationIndex || 0) % ROTATION.length;
        const workoutId = ROTATION[idx];

        data[workoutId] = today;                              // keep last-done date for the UI
        data.rotationIndex = (idx + 1) % ROTATION.length;    // advance rotation
        data.actionDate = today;                              // lock today's card
        data.history = data.history || [];
        data.history.push({ type: workoutId, date: today, advanced: true });

        await saveData(data);
        render(data);
        showToast('Logged \u2713');
      } finally {
        isProcessing = false;
      }
    }

    // "Skip Today" — logs an off day, rotation stays put
    async function skipToday() {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const today = todayStr();

        data.actionDate = today;
        data.history = data.history || [];
        data.history.push({ type: 'off', date: today, advanced: false });

        await saveData(data);
        render(data);
        showToast('Day off logged');
      } finally {
        isProcessing = false;
      }
    }

    // Undo — removes the most recent history entry if it's from today or yesterday
    async function undoLastEntry() {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const today = todayStr();
        const yesterday = getYesterdayStr();
        const history = data.history || [];
        if (!history.length) { render(data); return; }

        const last = history[history.length - 1];
        if (last.date !== today && last.date !== yesterday) { render(data); return; }

        const deletedSid = last._sid ?? null; // capture before removing so saveData can delete the right row

        // Remove the entry
        data.history = history.slice(0, -1);

        // Restore the previous last-done date for this workout type
        if (last.type !== 'off') {
          const prev = [...data.history].reverse().find(e => e.type === last.type);
          if (prev) {
            data[last.type] = prev.date;
          } else {
            delete data[last.type];
          }
        }

        // Roll back rotation if this entry advanced it.
        // New entries use advanced:true/false explicitly.
        // Old entries (no 'advanced' key) are assumed rotation-advancing if they're a workout,
        // since only markDone logged workouts before the advanced flag was introduced.
        const wasRotationAdvancing =
          last.advanced === true ||
          (!('advanced' in last) && last.type !== 'off');
        if (wasRotationAdvancing) {
          data.rotationIndex = ((data.rotationIndex || 0) - 1 + ROTATION.length) % ROTATION.length;
        }

        // Recalculate actionDate from what remains in history rather than guessing.
        // The card is locked today only if a rotation-advancing done or a skip still exists for today.
        const stillLockedToday = (data.history || []).some(e =>
          e.date === today && (
            e.advanced === true ||                          // new markDone entry
            e.type === 'off' ||                            // skip entry
            (!('advanced' in e) && e.type !== 'off')       // old entry without flag (backward compat)
          )
        );
        if (stillLockedToday) {
          data.actionDate = today;
        } else {
          delete data.actionDate;
        }

        await saveData(data, deletedSid);
        render(data);
        const name = last.type === 'off'
          ? 'day off'
          : (WORKOUTS.find(w => w.id === last.type)?.name ?? last.type);
        showToast(`Undone \u2014 ${name}`);
      } finally {
        isProcessing = false;
      }
    }

    // Log for yesterday — adds a history entry for yesterday without touching the rotation
    async function logYesterday(type) {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const yesterday = getYesterdayStr();

        if (type !== 'off') {
          // Only update the last-done date if yesterday is more recent than what's stored
          const current = data[type];
          if (!current || yesterday > current) {
            data[type] = yesterday;
          }
        }

        data.history = data.history || [];
        data.history.push({ type, date: yesterday, advanced: false });

        await saveData(data);
        render(data);
        const name = type === 'off'
          ? 'Day off'
          : (WORKOUTS.find(w => w.id === type)?.name ?? type);
        showToast(`${name} \u2014 logged for yesterday`);
      } finally {
        isProcessing = false;
      }
    }

    // Row-level done — marks a specific workout without affecting the rotation
    async function markRowDone(id) {
      if (isProcessing) return;
      isProcessing = true;
      setButtonsDisabled(true);
      try {
        const data = await loadData();
        const today = todayStr();

        data[id] = today;
        data.history = data.history || [];
        data.history.push({ type: id, date: today, advanced: false });

        await saveData(data);
        render(data);
        showToast('Logged \u2713');
      } finally {
        isProcessing = false;
      }
    }

    // ── History view state ──────────────────────────────────────────────────
    let cachedData = null;        // last-loaded data, used by history renders
    let historyViewActive = false;
    let historySubTab = 'calendar'; // 'calendar' or 'list'
    let calViewDate = new Date(); // month currently shown in the calendar

    // Convert a Date object → 'YYYY-MM-DD' string (local time)
    function dateToStr(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    // Build a lookup map: dateStr → last history entry for that date
    function buildHistoryMap(data) {
      const map = {};
      for (const entry of (data.history || [])) {
        // Later entries override earlier ones for the same date
        map[entry.date] = entry;
      }
      return map;
    }

    // Project future workouts: starting from today (or the first un-logged day),
    // assign one rotation workout per calendar day going forward (up to 365 days).
    // data.rotationIndex already accounts for all past logged workouts.
    function buildProjectionMap(data) {
      const histMap = buildHistoryMap(data);
      const map = {};
      let rotIdx = data.rotationIndex || 0;
      const start = new Date();
      start.setHours(0, 0, 0, 0);

      for (let i = 0; i <= 365; i++) {
        const d = new Date(start);
        d.setDate(d.getDate() + i);
        const ds = dateToStr(d);
        // Only project days that have no actual logged data
        if (!histMap[ds]) {
          map[ds] = ROTATION[rotIdx % ROTATION.length];
          rotIdx = (rotIdx + 1) % ROTATION.length;
        }
      }
      return map;
    }

    // ── Calendar renderer ───────────────────────────────────────────────────
    function renderCalendar(data) {
      const container = document.getElementById('hview-calendar');
      const histMap = buildHistoryMap(data);
      const projMap = buildProjectionMap(data);
      const today = todayStr();

      const year  = calViewDate.getFullYear();
      const month = calViewDate.getMonth(); // 0-indexed

      const MONTH_NAMES = [
        'January','February','March','April','May','June',
        'July','August','September','October','November','December',
      ];

      const firstDayDow = new Date(year, month, 1).getDay();  // 0=Sun
      const daysInMonth = new Date(year, month + 1, 0).getDate();

      let html = `
        <div class="cal-header">
          <button class="cal-nav-btn" id="cal-prev-btn">
            <i data-lucide="chevron-left"></i>
          </button>
          <span class="cal-month-label">${MONTH_NAMES[month]} ${year}</span>
          <button class="cal-nav-btn" id="cal-next-btn">
            <i data-lucide="chevron-right"></i>
          </button>
        </div>
        <div class="cal-grid">
      `;

      // Day-of-week column headers
      for (const d of ['S','M','T','W','T','F','S']) {
        html += `<div class="cal-dow">${d}</div>`;
      }

      // Empty filler cells before the 1st of the month
      for (let i = 0; i < firstDayDow; i++) {
        html += '<div class="cal-day"></div>';
      }

      // One cell per day
      for (let day = 1; day <= daysInMonth; day++) {
        const ds = `${year}-${String(month + 1).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
        const isToday   = ds === today;
        const isFuture  = ds > today;
        const histEntry = histMap[ds];
        const projId    = projMap[ds]; // set for un-logged days >= today

        const classes = ['cal-day'];
        if (isToday) classes.push('is-today');

        let iconHtml = '';

        if (histEntry) {
          // Actual logged data — show the real result
          if (histEntry.type === 'off') {
            classes.push('has-rest');
            iconHtml = '<i class="cal-icon" data-lucide="moon"></i>';
          } else {
            classes.push('has-workout');
            const w = WORKOUTS.find(w => w.id === histEntry.type);
            if (w) iconHtml = `<i class="cal-icon" data-lucide="${w.icon}"></i>`;
          }
        } else if (projId) {
          // No log yet (today un-actioned or a future date) — show projected
          classes.push('is-projected');
          const w = WORKOUTS.find(w => w.id === projId);
          if (w) iconHtml = `<i class="cal-icon" data-lucide="${w.icon}"></i>`;
        }
        // Past days with no data: just the number, no icon

        html += `<div class="${classes.join(' ')}">${iconHtml}<span class="cal-day-num">${day}</span></div>`;
      }

      html += '</div>';
      container.innerHTML = html;

      // Month navigation
      document.getElementById('cal-prev-btn').onclick = () => {
        calViewDate = new Date(calViewDate.getFullYear(), calViewDate.getMonth() - 1, 1);
        renderCalendar(data);
      };
      document.getElementById('cal-next-btn').onclick = () => {
        calViewDate = new Date(calViewDate.getFullYear(), calViewDate.getMonth() + 1, 1);
        renderCalendar(data);
      };

      if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    // ── History list renderer ───────────────────────────────────────────────
    function renderHistoryList(data) {
      const container = document.getElementById('hview-list');
      const today = todayStr();

      const MONTHS   = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const WEEKDAYS = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];

      // Build one row per history entry, most-recent first
      const entries = [...(data.history || [])].reverse();

      // Build 14 future projected days (starting tomorrow)
      const projMap = buildProjectionMap(data);
      const futureRows = [];
      for (let i = 1; i <= 14; i++) {
        const d = new Date();
        d.setHours(0, 0, 0, 0);
        d.setDate(d.getDate() + i);
        const ds = dateToStr(d);
        if (projMap[ds]) futureRows.push({ date: ds, type: projMap[ds] });
      }

      // Helper: build one list row's HTML
      function rowHtml(dateStr, type, isProjected, isToday) {
        const d = new Date(dateStr + 'T00:00:00');
        const thisYear = new Date().getFullYear();
        const yearSuffix = d.getFullYear() !== thisYear ? `, ${d.getFullYear()}` : '';
        const dateMain = `${MONTHS[d.getMonth()]} ${d.getDate()}${yearSuffix}`;
        const dayName  = WEEKDAYS[d.getDay()];

        const isOff    = type === 'off';
        const workout  = isOff ? null : WORKOUTS.find(w => w.id === type);
        const iconName = isOff ? 'moon' : (workout ? workout.icon : 'dumbbell');
        const color    = isOff ? 'amber' : 'purple';
        const dispName = isOff ? 'Rest Day' : (workout ? workout.name : type);

        const rowCls = [
          'hlist-row',
          isProjected ? 'is-projected' : '',
          isToday     ? 'is-today'     : '',
        ].filter(Boolean).join(' ');

        return `
          <div class="${rowCls}">
            <i class="hlist-icon ${color}" data-lucide="${iconName}"></i>
            <div class="hlist-date">
              <div class="hlist-date-main">${dateMain}</div>
              <div class="hlist-date-sub">${dayName}</div>
            </div>
            <div class="hlist-name ${color}">${dispName}</div>
          </div>`;
      }

      let html = '';

      if (entries.length) {
        html += '<div class="hlist">';
        for (const e of entries) {
          html += rowHtml(e.date, e.type, false, e.date === today);
        }
        html += '</div>';
      } else {
        html += '<div class="hlist-empty">No workouts logged yet.</div>';
      }

      if (futureRows.length) {
        html += '<div class="hlist-section-label">Coming Up</div>';
        html += '<div class="hlist">';
        for (const r of futureRows) {
          html += rowHtml(r.date, r.type, true, false);
        }
        html += '</div>';
      }

      container.innerHTML = html;
      if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    // Decide which history sub-view to render
    function renderHistoryView(data) {
      if (historySubTab === 'calendar') renderCalendar(data);
      else renderHistoryList(data);
    }

    // ── Tab switching ───────────────────────────────────────────────────────
    function switchMainTab(tab) {
      historyViewActive = tab === 'history';
      document.getElementById('view-today').hidden   = historyViewActive;
      document.getElementById('view-history').hidden = !historyViewActive;
      document.getElementById('nav-today-btn').classList.toggle('active', !historyViewActive);
      document.getElementById('nav-history-btn').classList.toggle('active', historyViewActive);
      if (historyViewActive && cachedData) renderHistoryView(cachedData);
    }

    function switchHistorySubTab(tab) {
      historySubTab = tab;
      document.getElementById('htab-calendar').classList.toggle('active', tab === 'calendar');
      document.getElementById('htab-list').classList.toggle('active', tab === 'list');
      document.getElementById('hview-calendar').hidden = tab !== 'calendar';
      document.getElementById('hview-list').hidden     = tab !== 'list';
      if (cachedData) renderHistoryView(cachedData);
    }

    // ── Nav event listeners ─────────────────────────────────────────────────
    document.getElementById('nav-today-btn').onclick   = () => switchMainTab('today');
    document.getElementById('nav-history-btn').onclick = () => switchMainTab('history');
    document.getElementById('htab-calendar').onclick   = () => switchHistorySubTab('calendar');
    document.getElementById('htab-list').onclick       = () => switchHistorySubTab('list');

    // ── Main render ─────────────────────────────────────────────────────────
    async function render(preloadedData = null) {
      const data = preloadedData || await loadData();
      cachedData = data; // cache so history renderers can access it on-demand

      const today = todayStr();
      const yesterday = getYesterdayStr();
      const nextInRotation = getSuggested(data);
      const actionTakenToday = data.actionDate === today;

      // What specifically happened today (if anything)
      const todayEntry = [...(data.history || [])].reverse().find(e => e.date === today);
      const skippedToday = todayEntry?.type === 'off';

      // Hero card stays on the completed workout for the rest of the day.
      // Only flip to the next rotation item when a new day begins.
      const heroWorkout = (actionTakenToday && !skippedToday && todayEntry)
        ? (WORKOUTS.find(w => w.id === todayEntry.type) || nextInRotation)
        : nextInRotation;

      // Date label
      document.getElementById('date-label').textContent = new Date().toLocaleDateString(
        undefined, { weekday: 'long', month: 'long', day: 'numeric' }
      );

      // Suggestion card
      const sugDays = data[heroWorkout.id] ? daysSince(data[heroWorkout.id]) : null;

      // Hero name — icon inline to the left of the text, matching the list row pattern
      const heroNameEl = document.getElementById('suggestion-name');
      heroNameEl.innerHTML = '';
      const heroIconEl = document.createElement('i');
      heroIconEl.setAttribute('data-lucide', heroWorkout.icon);
      heroIconEl.className = 'hero-icon';
      heroNameEl.appendChild(heroIconEl);
      heroNameEl.appendChild(document.createTextNode(heroWorkout.name));

      let subtitleText;
      if (skippedToday)        subtitleText = 'Day off \u2014 same workout tomorrow';
      else if (actionTakenToday) subtitleText = 'Completed today';
      else                       subtitleText = lastDoneText(sugDays, false);
      document.getElementById('suggestion-subtitle').textContent = subtitleText;

      const mainBtn = document.getElementById('main-done-btn');
      mainBtn.disabled = actionTakenToday;
      mainBtn.textContent = (actionTakenToday && !skippedToday) ? 'Done Today \u2713' : 'Done!';
      mainBtn.onclick = actionTakenToday ? null : markDone;

      const skipBtn = document.getElementById('skip-btn');
      skipBtn.disabled = actionTakenToday;
      skipBtn.textContent = skippedToday ? 'Skipped Today' : 'Skip Today';
      skipBtn.onclick = actionTakenToday ? null : skipToday;

      // Undo button — visible when the most recent history entry is from today or yesterday
      const history = data.history || [];
      const undoCandidate = history.length ? history[history.length - 1] : null;
      const undoBtn = document.getElementById('undo-btn');
      if (undoCandidate && (undoCandidate.date === today || undoCandidate.date === yesterday)) {
        const undoName = undoCandidate.type === 'off'
          ? 'day off'
          : (WORKOUTS.find(w => w.id === undoCandidate.type)?.name ?? undoCandidate.type);
        const undoWhen = undoCandidate.date === today ? 'today' : 'yesterday';
        undoBtn.textContent = `\u21a9 Undo ${undoName} (${undoWhen})`;
        undoBtn.onclick = undoLastEntry;
        undoBtn.hidden = false;
      } else {
        undoBtn.hidden = true;
      }

      // Tomorrow row — one step ahead of whatever is currently next
      // If action was taken today, rotation already advanced so nextInRotation IS tomorrow.
      // If today hasn't been actioned yet, rotation still points to today, so add 1.
      const tomorrowWorkout = actionTakenToday
        ? nextInRotation
        : WORKOUTS.find(w => w.id === ROTATION[((data.rotationIndex || 0) + 1) % ROTATION.length]);
      const tomorrowNameEl = document.getElementById('tomorrow-name');
      tomorrowNameEl.innerHTML = '';
      const tomorrowIconEl = document.createElement('i');
      tomorrowIconEl.setAttribute('data-lucide', tomorrowWorkout.icon);
      tomorrowIconEl.className = 'tomorrow-icon';
      tomorrowNameEl.appendChild(tomorrowIconEl);
      tomorrowNameEl.appendChild(document.createTextNode(tomorrowWorkout.name));

      // Workout list — suggested first, then by most recently done
      const sorted = [...WORKOUTS].sort((a, b) => {
        if (a.id === nextInRotation.id) return -1;
        if (b.id === nextInRotation.id) return 1;
        const doneA = data[a.id] === today;
        const doneB = data[b.id] === today;
        const daysA = data[a.id] ? daysSince(data[a.id]) : null;
        const daysB = data[b.id] ? daysSince(data[b.id]) : null;
        const scoreA = doneA ? -1 : (daysA === null ? Infinity : daysA);
        const scoreB = doneB ? -1 : (daysB === null ? Infinity : daysB);
        return scoreB - scoreA;
      });

      const list = document.getElementById('workout-list');
      list.innerHTML = '';

      for (const w of sorted) {
        const last = data[w.id];
        const days = last ? daysSince(last) : null;
        const doneToday = last === today;
        const isSuggested = w.id === nextInRotation.id;

        const row = document.createElement('div');
        row.className = [
          'workout-row',
          isSuggested ? 'is-suggested' : '',
          doneToday   ? 'done-today'   : '',
        ].filter(Boolean).join(' ');

        const info = document.createElement('div');
        info.className = 'workout-info';

        const nameEl = document.createElement('div');
        nameEl.className = 'workout-name';
        const rowIconEl = document.createElement('i');
        rowIconEl.setAttribute('data-lucide', w.icon);
        rowIconEl.className = 'row-icon';
        const nameSpan = document.createElement('span');
        nameSpan.textContent = w.name;
        nameEl.appendChild(rowIconEl);
        nameEl.appendChild(nameSpan);

        const lastEl = document.createElement('div');
        lastEl.className = 'workout-last';
        lastEl.textContent = lastDoneText(days, doneToday);

        info.appendChild(nameEl);
        info.appendChild(lastEl);

        // "Log for yesterday" link — hidden if this workout was already logged for yesterday
        const alreadyLoggedYesterday = history.some(e => e.date === yesterday && e.type === w.id);
        if (!alreadyLoggedYesterday) {
          const yLink = document.createElement('button');
          yLink.className = 'log-yesterday-link';
          yLink.textContent = '\u21a9 Log for yesterday';
          yLink.onclick = () => logYesterday(w.id);
          info.appendChild(yLink);
        }

        const pill = document.createElement('span');
        pill.className = 'days-pill ' + pillClass(days, doneToday);
        pill.textContent = pillText(days, doneToday);

        const btn = document.createElement('button');
        btn.className = 'row-done-btn';
        btn.textContent = doneToday ? '\u2713' : 'Done';
        btn.disabled = doneToday;
        if (!doneToday) btn.onclick = () => markRowDone(w.id);

        row.appendChild(info);
        row.appendChild(pill);
        row.appendChild(btn);
        list.appendChild(row);
      }

      // If the history view is visible, keep it in sync with the new data
      if (historyViewActive) renderHistoryView(data);

      // Replace all data-lucide placeholder elements with SVG icons
      if (typeof lucide !== 'undefined') lucide.createIcons();

    }

    render();

  }); // end DOMContentLoaded

  // Register service worker outside DOMContentLoaded so it starts as early as
  // possible — it does not depend on the Supabase client.
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js').catch(() => {});
    });
  }
  </script>
</body>
</html>
